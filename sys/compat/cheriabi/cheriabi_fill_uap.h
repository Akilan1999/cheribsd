/*
 * Functions to fill syscall uap structs.
 *
 * DO NOT EDIT-- this file is automatically generated.
 * $FreeBSD$
 * created from FreeBSD
 */

#ifndef _SYS_COMPAT_CHERIABI_FILL_UAP_H_
#define	_SYS_COMPAT_CHERIABI_FILL_UAP_H_

static inline int
CHERIABI_SYS_exit_fill_uap(struct thread *td,
    struct sys_exit_args *uap)
{
	struct chericap tmpcap;

	/* [0] int rval */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_exit, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->rval, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_read_fill_uap(struct thread *td,
    struct read_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_read, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] size_t nbyte */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_read, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nbyte, CHERI_CR_CTEMP0);

	/* [1] _Out_writes_bytes_(nbyte) void * buf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_read, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->nbyte)
			return (EPROT);

		CHERI_CTOPTR(uap->buf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_write_fill_uap(struct thread *td,
    struct write_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_write, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] size_t nbyte */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_write, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nbyte, CHERI_CR_CTEMP0);

	/* [1] _In_reads_bytes_(nbyte) const void * buf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_write, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->nbyte)
			return (EPROT);

		CHERI_CTOPTR(uap->buf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_open_fill_uap(struct thread *td,
    struct open_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_open, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [2] int mode */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_open, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->mode, CHERI_CR_CTEMP0);

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_open, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_close_fill_uap(struct thread *td,
    struct close_args *uap)
{
	struct chericap tmpcap;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_close, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_wait4_fill_uap(struct thread *td,
    struct wait4_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int pid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_wait4, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->pid, CHERI_CR_CTEMP0);

	/* [2] int options */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_wait4, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->options, CHERI_CR_CTEMP0);

	/* [1] _Out_opt_ int * status */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_wait4, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->status, CHERI_CR_CTEMP0);
		if (uap->status != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->status))
			return (EPROT);

		CHERI_CTOPTR(uap->status, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _Out_opt_ struct rusage * rusage */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_wait4, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->rusage, CHERI_CR_CTEMP0);
		if (uap->rusage != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->rusage))
			return (EPROT);

		CHERI_CTOPTR(uap->rusage, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_link_fill_uap(struct thread *td,
    struct link_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_link, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _In_z_ char * link */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_link, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->link))
			return (EPROT);

		CHERI_CTOPTR(uap->link, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_unlink_fill_uap(struct thread *td,
    struct unlink_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_unlink, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_chdir_fill_uap(struct thread *td,
    struct chdir_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_chdir, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fchdir_fill_uap(struct thread *td,
    struct fchdir_args *uap)
{
	struct chericap tmpcap;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fchdir, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_mknod_fill_uap(struct thread *td,
    struct mknod_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int mode */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mknod, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->mode, CHERI_CR_CTEMP0);

	/* [2] int dev */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mknod, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->dev, CHERI_CR_CTEMP0);

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mknod, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_chmod_fill_uap(struct thread *td,
    struct chmod_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int mode */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_chmod, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->mode, CHERI_CR_CTEMP0);

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_chmod, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_chown_fill_uap(struct thread *td,
    struct chown_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int uid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_chown, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->uid, CHERI_CR_CTEMP0);

	/* [2] int gid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_chown, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->gid, CHERI_CR_CTEMP0);

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_chown, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_mount_fill_uap(struct thread *td,
    struct mount_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [2] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mount, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [0] _In_z_ char * type */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mount, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->type))
			return (EPROT);

		CHERI_CTOPTR(uap->type, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mount, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _In_opt_ caddr_t data */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mount, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->data, CHERI_CR_CTEMP0);
		if (uap->data != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->data))
			return (EPROT);

		CHERI_CTOPTR(uap->data, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_unmount_fill_uap(struct thread *td,
    struct unmount_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_unmount, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_unmount, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setuid_fill_uap(struct thread *td,
    struct setuid_args *uap)
{
	struct chericap tmpcap;

	/* [0] uid_t uid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setuid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->uid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_ptrace_fill_uap(struct thread *td,
    struct ptrace_args *uap)
{
	struct chericap tmpcap;

	/* [0] int req */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ptrace, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->req, CHERI_CR_CTEMP0);

	/* [1] pid_t pid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ptrace, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->pid, CHERI_CR_CTEMP0);

	/* [2] vaddr_t addr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ptrace, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->addr, CHERI_CR_CTEMP0);

	/* [3] int data */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ptrace, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->data, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_recvmsg_fill_uap(struct thread *td,
    struct cheriabi_recvmsg_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int s */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_recvmsg, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->s, CHERI_CR_CTEMP0);

	/* [2] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_recvmsg, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [1] _In_ struct msghdr_c * msg */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_recvmsg, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->msg))
			return (EPROT);

		CHERI_CTOPTR(uap->msg, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_sendmsg_fill_uap(struct thread *td,
    struct cheriabi_sendmsg_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int s */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sendmsg, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->s, CHERI_CR_CTEMP0);

	/* [2] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sendmsg, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [1] _In_ struct msghdr_c * msg */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sendmsg, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->msg))
			return (EPROT);

		CHERI_CTOPTR(uap->msg, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_recvfrom_fill_uap(struct thread *td,
    struct recvfrom_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int s */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_recvfrom, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->s, CHERI_CR_CTEMP0);

	/* [2] size_t len */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_recvfrom, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->len, CHERI_CR_CTEMP0);

	/* [3] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_recvfrom, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [1] _Out_writes_bytes_(len) caddr_t buf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_recvfrom, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->len)
			return (EPROT);

		CHERI_CTOPTR(uap->buf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [5] _Inout_opt_ socklen_t *restrict fromlenaddr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_recvfrom, 5);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->fromlenaddr, CHERI_CR_CTEMP0);
		if (uap->fromlenaddr != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->fromlenaddr))
			return (EPROT);

		CHERI_CTOPTR(uap->fromlenaddr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [4] _Out_writes_bytes_opt_(*fromlenaddr) struct sockaddr *restrict from */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_recvfrom, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->from, CHERI_CR_CTEMP0);
		if (uap->from != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		if (uap->fromlenaddr == NULL)
			return (EINVAL);
		size_t reqlen;
		if (sizeof(uap->fromlenaddr) == 2)
			reqlen = fuword16(uap->fromlenaddr);
		else if (sizeof(uap->fromlenaddr) == 4)
			reqlen = fuword32(uap->fromlenaddr);
		else if (sizeof(uap->fromlenaddr) == 8)
			reqlen = fuword64(uap->fromlenaddr);
		else
			panic("unhandled dependant argument size %zu", sizeof(uap->fromlenaddr));
		reqlen = fuword(uap->fromlenaddr);
		if (reqlen == -1)
			return (EINVAL);
		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < reqlen)
			return (EPROT);

		CHERI_CTOPTR(uap->from, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_accept_fill_uap(struct thread *td,
    struct accept_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int s */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_accept, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->s, CHERI_CR_CTEMP0);

	/* [2] _Inout_opt_ socklen_t * anamelen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_accept, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->anamelen, CHERI_CR_CTEMP0);
		if (uap->anamelen != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->anamelen))
			return (EPROT);

		CHERI_CTOPTR(uap->anamelen, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_writes_bytes_(*anamelen) struct sockaddr *restrict name */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_accept, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		if (uap->anamelen == NULL)
			return (EINVAL);
		size_t reqlen;
		if (sizeof(uap->anamelen) == 2)
			reqlen = fuword16(uap->anamelen);
		else if (sizeof(uap->anamelen) == 4)
			reqlen = fuword32(uap->anamelen);
		else if (sizeof(uap->anamelen) == 8)
			reqlen = fuword64(uap->anamelen);
		else
			panic("unhandled dependant argument size %zu", sizeof(uap->anamelen));
		reqlen = fuword(uap->anamelen);
		if (reqlen == -1)
			return (EINVAL);
		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < reqlen)
			return (EPROT);

		CHERI_CTOPTR(uap->name, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getpeername_fill_uap(struct thread *td,
    struct getpeername_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fdes */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getpeername, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fdes, CHERI_CR_CTEMP0);

	/* [2] _Inout_opt_ socklen_t * alen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getpeername, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->alen, CHERI_CR_CTEMP0);
		if (uap->alen != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->alen))
			return (EPROT);

		CHERI_CTOPTR(uap->alen, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_writes_bytes_(*alen) struct sockaddr *restrict asa */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getpeername, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		if (uap->alen == NULL)
			return (EINVAL);
		size_t reqlen;
		if (sizeof(uap->alen) == 2)
			reqlen = fuword16(uap->alen);
		else if (sizeof(uap->alen) == 4)
			reqlen = fuword32(uap->alen);
		else if (sizeof(uap->alen) == 8)
			reqlen = fuword64(uap->alen);
		else
			panic("unhandled dependant argument size %zu", sizeof(uap->alen));
		reqlen = fuword(uap->alen);
		if (reqlen == -1)
			return (EINVAL);
		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < reqlen)
			return (EPROT);

		CHERI_CTOPTR(uap->asa, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getsockname_fill_uap(struct thread *td,
    struct getsockname_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fdes */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getsockname, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fdes, CHERI_CR_CTEMP0);

	/* [2] _Inout_ socklen_t * alen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getsockname, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->alen))
			return (EPROT);

		CHERI_CTOPTR(uap->alen, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_writes_bytes_(*alen) struct sockaddr *restrict asa */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getsockname, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		if (uap->alen == NULL)
			return (EINVAL);
		size_t reqlen;
		if (sizeof(uap->alen) == 2)
			reqlen = fuword16(uap->alen);
		else if (sizeof(uap->alen) == 4)
			reqlen = fuword32(uap->alen);
		else if (sizeof(uap->alen) == 8)
			reqlen = fuword64(uap->alen);
		else
			panic("unhandled dependant argument size %zu", sizeof(uap->alen));
		reqlen = fuword(uap->alen);
		if (reqlen == -1)
			return (EINVAL);
		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < reqlen)
			return (EPROT);

		CHERI_CTOPTR(uap->asa, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_access_fill_uap(struct thread *td,
    struct access_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int amode */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_access, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->amode, CHERI_CR_CTEMP0);

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_access, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_chflags_fill_uap(struct thread *td,
    struct chflags_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] u_long flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_chflags, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_chflags, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fchflags_fill_uap(struct thread *td,
    struct fchflags_args *uap)
{
	struct chericap tmpcap;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fchflags, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] u_long flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fchflags, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_kill_fill_uap(struct thread *td,
    struct kill_args *uap)
{
	struct chericap tmpcap;

	/* [0] int pid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kill, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->pid, CHERI_CR_CTEMP0);

	/* [1] int signum */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kill, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->signum, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_dup_fill_uap(struct thread *td,
    struct dup_args *uap)
{
	struct chericap tmpcap;

	/* [0] u_int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_dup, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_profil_fill_uap(struct thread *td,
    struct profil_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] size_t size */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_profil, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->size, CHERI_CR_CTEMP0);

	/* [2] size_t offset */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_profil, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->offset, CHERI_CR_CTEMP0);

	/* [3] u_int scale */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_profil, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->scale, CHERI_CR_CTEMP0);

	/* [0] _Out_writes_bytes_(size) caddr_t samples */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_profil, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->size)
			return (EPROT);

		CHERI_CTOPTR(uap->samples, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ktrace_fill_uap(struct thread *td,
    struct ktrace_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int ops */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ktrace, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->ops, CHERI_CR_CTEMP0);

	/* [2] int facs */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ktrace, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->facs, CHERI_CR_CTEMP0);

	/* [3] int pid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ktrace, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->pid, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * fname */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ktrace, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->fname))
			return (EPROT);

		CHERI_CTOPTR(uap->fname, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getlogin_fill_uap(struct thread *td,
    struct getlogin_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] u_int namelen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getlogin, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->namelen, CHERI_CR_CTEMP0);

	/* [0] _Out_writes_z_(namelen) char * namebuf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getlogin, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->namebuf) * uap->namelen))
			return (EPROT);

		CHERI_CTOPTR(uap->namebuf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setlogin_fill_uap(struct thread *td,
    struct setlogin_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * namebuf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setlogin, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->namebuf))
			return (EPROT);

		CHERI_CTOPTR(uap->namebuf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_acct_fill_uap(struct thread *td,
    struct acct_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_acct, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_sigaltstack_fill_uap(struct thread *td,
    struct cheriabi_sigaltstack_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_opt_ const cheriabi_stack_t * ss */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigaltstack, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->ss, CHERI_CR_CTEMP0);
		if (uap->ss != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->ss))
			return (EPROT);

		CHERI_CTOPTR(uap->ss, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_opt_ cheriabi_stack_t * oss */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigaltstack, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->oss, CHERI_CR_CTEMP0);
		if (uap->oss != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->oss))
			return (EPROT);

		CHERI_CTOPTR(uap->oss, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int	CHERIABI_SYS_cheriabi_ioctl_fill_uap(struct thread *td,
    struct cheriabi_ioctl_args *uap);

static inline int
CHERIABI_SYS_reboot_fill_uap(struct thread *td,
    struct reboot_args *uap)
{
	struct chericap tmpcap;

	/* [0] int opt */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_reboot, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->opt, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_revoke_fill_uap(struct thread *td,
    struct revoke_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_revoke, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_symlink_fill_uap(struct thread *td,
    struct symlink_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_symlink, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _In_z_ const char * link */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_symlink, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->link))
			return (EPROT);

		CHERI_CTOPTR(uap->link, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_readlink_fill_uap(struct thread *td,
    struct readlink_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [2] size_t count */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_readlink, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->count, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_readlink, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_writes_z_(count) char * buf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_readlink, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->buf) * uap->count))
			return (EPROT);

		CHERI_CTOPTR(uap->buf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_execve_fill_uap(struct thread *td,
    struct cheriabi_execve_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * fname */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_execve, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->fname))
			return (EPROT);

		CHERI_CTOPTR(uap->fname, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _In_ struct chericap * argv */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_execve, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->argv))
			return (EPROT);

		CHERI_CTOPTR(uap->argv, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_ struct chericap * envv */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_execve, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->envv))
			return (EPROT);

		CHERI_CTOPTR(uap->envv, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_umask_fill_uap(struct thread *td,
    struct umask_args *uap)
{
	struct chericap tmpcap;

	/* [0] int newmask */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_umask, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->newmask, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_chroot_fill_uap(struct thread *td,
    struct chroot_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_chroot, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_msync_fill_uap(struct thread *td,
    struct msync_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] size_t len */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_msync, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->len, CHERI_CR_CTEMP0);

	/* [2] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_msync, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [0] _Pagerange_(len) void * addr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_msync, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		CHERI_CGETLEN(base, CHERI_CR_CTEMP0);
		if (rounddown2(base + offset, PAGE_SIZE) < base)
			return (EPROT);
		size_t adjust;
		adjust = ((base + offset) & PAGE_MASK);
		length += adjust;
		if (length < roundup2(uap->len + adjust, PAGE_SIZE))
			return (EPROT);

		CHERI_CTOPTR(uap->addr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_vadvise_fill_uap(struct thread *td,
    struct ovadvise_args *uap)
{
	struct chericap tmpcap;

	/* [0] int anom */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_vadvise, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->anom, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_munmap_fill_uap(struct thread *td,
    struct munmap_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] size_t len */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_munmap, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->len, CHERI_CR_CTEMP0);

	/* [0] _Pagerange_(len) void * addr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_munmap, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		CHERI_CGETLEN(base, CHERI_CR_CTEMP0);
		if (rounddown2(base + offset, PAGE_SIZE) < base)
			return (EPROT);
		size_t adjust;
		adjust = ((base + offset) & PAGE_MASK);
		length += adjust;
		if (length < roundup2(uap->len + adjust, PAGE_SIZE))
			return (EPROT);

		CHERI_CTOPTR(uap->addr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_mprotect_fill_uap(struct thread *td,
    struct mprotect_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] size_t len */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mprotect, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->len, CHERI_CR_CTEMP0);

	/* [2] int prot */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mprotect, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->prot, CHERI_CR_CTEMP0);

	/* [0] _Pagerange_(len) const void * addr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mprotect, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		CHERI_CGETLEN(base, CHERI_CR_CTEMP0);
		if (rounddown2(base + offset, PAGE_SIZE) < base)
			return (EPROT);
		size_t adjust;
		adjust = ((base + offset) & PAGE_MASK);
		length += adjust;
		if (length < roundup2(uap->len + adjust, PAGE_SIZE))
			return (EPROT);

		CHERI_CTOPTR(uap->addr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_madvise_fill_uap(struct thread *td,
    struct madvise_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] size_t len */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_madvise, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->len, CHERI_CR_CTEMP0);

	/* [2] int behav */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_madvise, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->behav, CHERI_CR_CTEMP0);

	/* [0] _Pagerange_(len) void * addr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_madvise, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		CHERI_CGETLEN(base, CHERI_CR_CTEMP0);
		if (rounddown2(base + offset, PAGE_SIZE) < base)
			return (EPROT);
		size_t adjust;
		adjust = ((base + offset) & PAGE_MASK);
		length += adjust;
		if (length < roundup2(uap->len + adjust, PAGE_SIZE))
			return (EPROT);

		CHERI_CTOPTR(uap->addr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int	CHERIABI_SYS_mincore_fill_uap(struct thread *td,
    struct mincore_args *uap);

static inline int
CHERIABI_SYS_getgroups_fill_uap(struct thread *td,
    struct getgroups_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] u_int gidsetsize */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getgroups, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->gidsetsize, CHERI_CR_CTEMP0);

	/* [1] _Out_writes_(gidsetsize) gid_t * gidset */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getgroups, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->gidset) * uap->gidsetsize))
			return (EPROT);

		CHERI_CTOPTR(uap->gidset, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setgroups_fill_uap(struct thread *td,
    struct setgroups_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] u_int gidsetsize */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setgroups, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->gidsetsize, CHERI_CR_CTEMP0);

	/* [1] _In_reads_(gidsetsize) gid_t * gidset */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setgroups, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->gidset) * uap->gidsetsize))
			return (EPROT);

		CHERI_CTOPTR(uap->gidset, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setpgid_fill_uap(struct thread *td,
    struct setpgid_args *uap)
{
	struct chericap tmpcap;

	/* [0] int pid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setpgid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->pid, CHERI_CR_CTEMP0);

	/* [1] int pgid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setpgid, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->pgid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_setitimer_fill_uap(struct thread *td,
    struct setitimer_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] u_int which */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setitimer, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->which, CHERI_CR_CTEMP0);

	/* [1] _In_ struct itimerval * itv */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setitimer, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->itv))
			return (EPROT);

		CHERI_CTOPTR(uap->itv, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Out_opt_ struct itimerval * oitv */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setitimer, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->oitv, CHERI_CR_CTEMP0);
		if (uap->oitv != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->oitv))
			return (EPROT);

		CHERI_CTOPTR(uap->oitv, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_swapon_fill_uap(struct thread *td,
    struct swapon_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * name */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_swapon, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->name))
			return (EPROT);

		CHERI_CTOPTR(uap->name, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getitimer_fill_uap(struct thread *td,
    struct getitimer_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] u_int which */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getitimer, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->which, CHERI_CR_CTEMP0);

	/* [1] _Out_ struct itimerval * itv */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getitimer, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->itv))
			return (EPROT);

		CHERI_CTOPTR(uap->itv, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_dup2_fill_uap(struct thread *td,
    struct dup2_args *uap)
{
	struct chericap tmpcap;

	/* [0] u_int from */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_dup2, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->from, CHERI_CR_CTEMP0);

	/* [1] u_int to */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_dup2, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->to, CHERI_CR_CTEMP0);

	return (0);
}

static inline int	CHERIABI_SYS_fcntl_fill_uap(struct thread *td,
    struct fcntl_args *uap);

static inline int
CHERIABI_SYS_select_fill_uap(struct thread *td,
    struct select_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int nd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_select, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nd, CHERI_CR_CTEMP0);

	/* [1] _Inout_opt_ fd_set * in */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_select, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->in, CHERI_CR_CTEMP0);
		if (uap->in != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->in))
			return (EPROT);

		CHERI_CTOPTR(uap->in, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Inout_opt_ fd_set * ou */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_select, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->ou, CHERI_CR_CTEMP0);
		if (uap->ou != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->ou))
			return (EPROT);

		CHERI_CTOPTR(uap->ou, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _Inout_opt_ fd_set * ex */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_select, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->ex, CHERI_CR_CTEMP0);
		if (uap->ex != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->ex))
			return (EPROT);

		CHERI_CTOPTR(uap->ex, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [4] _In_opt_ struct timeval * tv */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_select, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->tv, CHERI_CR_CTEMP0);
		if (uap->tv != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->tv))
			return (EPROT);

		CHERI_CTOPTR(uap->tv, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fsync_fill_uap(struct thread *td,
    struct fsync_args *uap)
{
	struct chericap tmpcap;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fsync, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_setpriority_fill_uap(struct thread *td,
    struct setpriority_args *uap)
{
	struct chericap tmpcap;

	/* [0] int which */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setpriority, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->which, CHERI_CR_CTEMP0);

	/* [1] int who */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setpriority, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->who, CHERI_CR_CTEMP0);

	/* [2] int prio */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setpriority, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->prio, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_socket_fill_uap(struct thread *td,
    struct socket_args *uap)
{
	struct chericap tmpcap;

	/* [0] int domain */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_socket, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->domain, CHERI_CR_CTEMP0);

	/* [1] int type */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_socket, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->type, CHERI_CR_CTEMP0);

	/* [2] int protocol */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_socket, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->protocol, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_connect_fill_uap(struct thread *td,
    struct connect_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int s */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_connect, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->s, CHERI_CR_CTEMP0);

	/* [2] int namelen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_connect, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->namelen, CHERI_CR_CTEMP0);

	/* [1] _In_reads_bytes_(namelen) caddr_t name */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_connect, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->namelen)
			return (EPROT);

		CHERI_CTOPTR(uap->name, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getpriority_fill_uap(struct thread *td,
    struct getpriority_args *uap)
{
	struct chericap tmpcap;

	/* [0] int which */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getpriority, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->which, CHERI_CR_CTEMP0);

	/* [1] int who */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getpriority, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->who, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_bind_fill_uap(struct thread *td,
    struct bind_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int s */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_bind, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->s, CHERI_CR_CTEMP0);

	/* [2] int namelen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_bind, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->namelen, CHERI_CR_CTEMP0);

	/* [1] _In_reads_bytes_(namelen) caddr_t name */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_bind, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->namelen)
			return (EPROT);

		CHERI_CTOPTR(uap->name, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setsockopt_fill_uap(struct thread *td,
    struct setsockopt_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int s */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setsockopt, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->s, CHERI_CR_CTEMP0);

	/* [1] int level */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setsockopt, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->level, CHERI_CR_CTEMP0);

	/* [2] int name */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setsockopt, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->name, CHERI_CR_CTEMP0);

	/* [4] int valsize */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setsockopt, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->valsize, CHERI_CR_CTEMP0);

	/* [3] _In_reads_bytes_opt_(valsize) caddr_t val */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setsockopt, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->val, CHERI_CR_CTEMP0);
		if (uap->val != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->valsize)
			return (EPROT);

		CHERI_CTOPTR(uap->val, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_listen_fill_uap(struct thread *td,
    struct listen_args *uap)
{
	struct chericap tmpcap;

	/* [0] int s */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_listen, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->s, CHERI_CR_CTEMP0);

	/* [1] int backlog */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_listen, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->backlog, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_gettimeofday_fill_uap(struct thread *td,
    struct gettimeofday_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _Out_ struct timeval * tp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_gettimeofday, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->tp))
			return (EPROT);

		CHERI_CTOPTR(uap->tp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_opt_ struct timezone * tzp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_gettimeofday, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->tzp, CHERI_CR_CTEMP0);
		if (uap->tzp != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->tzp))
			return (EPROT);

		CHERI_CTOPTR(uap->tzp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getrusage_fill_uap(struct thread *td,
    struct getrusage_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int who */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getrusage, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->who, CHERI_CR_CTEMP0);

	/* [1] _Out_ struct rusage * rusage */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getrusage, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->rusage))
			return (EPROT);

		CHERI_CTOPTR(uap->rusage, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getsockopt_fill_uap(struct thread *td,
    struct getsockopt_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int s */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getsockopt, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->s, CHERI_CR_CTEMP0);

	/* [1] int level */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getsockopt, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->level, CHERI_CR_CTEMP0);

	/* [2] int name */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getsockopt, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->name, CHERI_CR_CTEMP0);

	/* [4] _Inout_ socklen_t * avalsize */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getsockopt, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->avalsize))
			return (EPROT);

		CHERI_CTOPTR(uap->avalsize, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _Out_writes_bytes_opt_(*avalsize) caddr_t val */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getsockopt, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->val, CHERI_CR_CTEMP0);
		if (uap->val != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		if (uap->avalsize == NULL)
			return (EINVAL);
		size_t reqlen;
		if (sizeof(uap->avalsize) == 2)
			reqlen = fuword16(uap->avalsize);
		else if (sizeof(uap->avalsize) == 4)
			reqlen = fuword32(uap->avalsize);
		else if (sizeof(uap->avalsize) == 8)
			reqlen = fuword64(uap->avalsize);
		else
			panic("unhandled dependant argument size %zu", sizeof(uap->avalsize));
		reqlen = fuword(uap->avalsize);
		if (reqlen == -1)
			return (EINVAL);
		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < reqlen)
			return (EPROT);

		CHERI_CTOPTR(uap->val, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_readv_fill_uap(struct thread *td,
    struct cheriabi_readv_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_readv, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] u_int iovcnt */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_readv, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->iovcnt, CHERI_CR_CTEMP0);

	/* [1] _Inout_updates_(iovcnt) struct iovec_c * iovp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_readv, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->iovp) * uap->iovcnt))
			return (EPROT);

		CHERI_CTOPTR(uap->iovp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_writev_fill_uap(struct thread *td,
    struct cheriabi_writev_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_writev, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] u_int iovcnt */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_writev, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->iovcnt, CHERI_CR_CTEMP0);

	/* [1] _In_reads_(iovcnt) struct iovec_c * iovp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_writev, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->iovp) * uap->iovcnt))
			return (EPROT);

		CHERI_CTOPTR(uap->iovp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_settimeofday_fill_uap(struct thread *td,
    struct settimeofday_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ struct timeval * tv */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_settimeofday, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->tv))
			return (EPROT);

		CHERI_CTOPTR(uap->tv, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _In_opt_ struct timezone * tzp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_settimeofday, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->tzp, CHERI_CR_CTEMP0);
		if (uap->tzp != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->tzp))
			return (EPROT);

		CHERI_CTOPTR(uap->tzp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fchown_fill_uap(struct thread *td,
    struct fchown_args *uap)
{
	struct chericap tmpcap;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fchown, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] int uid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fchown, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->uid, CHERI_CR_CTEMP0);

	/* [2] int gid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fchown, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->gid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_fchmod_fill_uap(struct thread *td,
    struct fchmod_args *uap)
{
	struct chericap tmpcap;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fchmod, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] int mode */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fchmod, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->mode, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_setreuid_fill_uap(struct thread *td,
    struct setreuid_args *uap)
{
	struct chericap tmpcap;

	/* [0] int ruid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setreuid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->ruid, CHERI_CR_CTEMP0);

	/* [1] int euid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setreuid, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->euid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_setregid_fill_uap(struct thread *td,
    struct setregid_args *uap)
{
	struct chericap tmpcap;

	/* [0] int rgid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setregid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->rgid, CHERI_CR_CTEMP0);

	/* [1] int egid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setregid, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->egid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_rename_fill_uap(struct thread *td,
    struct rename_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * from */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rename, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->from))
			return (EPROT);

		CHERI_CTOPTR(uap->from, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _In_z_ char * to */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rename, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->to))
			return (EPROT);

		CHERI_CTOPTR(uap->to, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_flock_fill_uap(struct thread *td,
    struct flock_args *uap)
{
	struct chericap tmpcap;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_flock, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] int how */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_flock, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->how, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_mkfifo_fill_uap(struct thread *td,
    struct mkfifo_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int mode */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mkfifo, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->mode, CHERI_CR_CTEMP0);

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mkfifo, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sendto_fill_uap(struct thread *td,
    struct sendto_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int s */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sendto, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->s, CHERI_CR_CTEMP0);

	/* [2] size_t len */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sendto, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->len, CHERI_CR_CTEMP0);

	/* [3] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sendto, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [5] int tolen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sendto, 5);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->tolen, CHERI_CR_CTEMP0);

	/* [1] _In_reads_bytes_(len) caddr_t buf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sendto, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->len)
			return (EPROT);

		CHERI_CTOPTR(uap->buf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [4] _In_reads_bytes_(tolen) caddr_t to */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sendto, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->tolen)
			return (EPROT);

		CHERI_CTOPTR(uap->to, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_shutdown_fill_uap(struct thread *td,
    struct shutdown_args *uap)
{
	struct chericap tmpcap;

	/* [0] int s */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_shutdown, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->s, CHERI_CR_CTEMP0);

	/* [1] int how */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_shutdown, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->how, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_socketpair_fill_uap(struct thread *td,
    struct socketpair_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int domain */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_socketpair, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->domain, CHERI_CR_CTEMP0);

	/* [1] int type */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_socketpair, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->type, CHERI_CR_CTEMP0);

	/* [2] int protocol */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_socketpair, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->protocol, CHERI_CR_CTEMP0);

	/* [3] _Out_writes_(2) int * rsv */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_socketpair, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->rsv) * 2))
			return (EPROT);

		CHERI_CTOPTR(uap->rsv, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_mkdir_fill_uap(struct thread *td,
    struct mkdir_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int mode */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mkdir, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->mode, CHERI_CR_CTEMP0);

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mkdir, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_rmdir_fill_uap(struct thread *td,
    struct rmdir_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rmdir, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_utimes_fill_uap(struct thread *td,
    struct utimes_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_utimes, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _In_ struct timeval * tptr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_utimes, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->tptr))
			return (EPROT);

		CHERI_CTOPTR(uap->tptr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_adjtime_fill_uap(struct thread *td,
    struct adjtime_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ struct timeval * delta */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_adjtime, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->delta))
			return (EPROT);

		CHERI_CTOPTR(uap->delta, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_opt_ struct timeval * olddelta */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_adjtime, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->olddelta, CHERI_CR_CTEMP0);
		if (uap->olddelta != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->olddelta))
			return (EPROT);

		CHERI_CTOPTR(uap->olddelta, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_quotactl_fill_uap(struct thread *td,
    struct quotactl_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int cmd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_quotactl, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->cmd, CHERI_CR_CTEMP0);

	/* [2] int uid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_quotactl, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->uid, CHERI_CR_CTEMP0);

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_quotactl, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _In_ caddr_t arg */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_quotactl, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->arg))
			return (EPROT);

		CHERI_CTOPTR(uap->arg, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_nlm_syscall_fill_uap(struct thread *td,
    struct cheriabi_nlm_syscall_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int debug_level */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_nlm_syscall, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->debug_level, CHERI_CR_CTEMP0);

	/* [1] int grace_period */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_nlm_syscall, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->grace_period, CHERI_CR_CTEMP0);

	/* [2] int addr_count */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_nlm_syscall, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->addr_count, CHERI_CR_CTEMP0);

	/* [3] _In_reads_(addr_count) struct chericap * addrs */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_nlm_syscall, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->addrs) * uap->addr_count))
			return (EPROT);

		CHERI_CTOPTR(uap->addrs, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_nfssvc_fill_uap(struct thread *td,
    struct cheriabi_nfssvc_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int flag */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_nfssvc, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flag, CHERI_CR_CTEMP0);

	/* [1] _In_ caddr_t argp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_nfssvc, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->argp))
			return (EPROT);

		CHERI_CTOPTR(uap->argp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_lgetfh_fill_uap(struct thread *td,
    struct lgetfh_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * fname */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lgetfh, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->fname))
			return (EPROT);

		CHERI_CTOPTR(uap->fname, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_ struct fhandle * fhp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lgetfh, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->fhp))
			return (EPROT);

		CHERI_CTOPTR(uap->fhp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getfh_fill_uap(struct thread *td,
    struct getfh_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * fname */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getfh, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->fname))
			return (EPROT);

		CHERI_CTOPTR(uap->fname, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_ struct fhandle * fhp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getfh, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->fhp))
			return (EPROT);

		CHERI_CTOPTR(uap->fhp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int	CHERIABI_SYS_cheriabi_sysarch_fill_uap(struct thread *td,
    struct cheriabi_sysarch_args *uap);

static inline int
CHERIABI_SYS_rtprio_fill_uap(struct thread *td,
    struct rtprio_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int function */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rtprio, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->function, CHERI_CR_CTEMP0);

	/* [1] pid_t pid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rtprio, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->pid, CHERI_CR_CTEMP0);

	/* [2] _Inout_ struct rtprio * rtp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rtprio, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->rtp))
			return (EPROT);

		CHERI_CTOPTR(uap->rtp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setfib_fill_uap(struct thread *td,
    struct setfib_args *uap)
{
	struct chericap tmpcap;

	/* [0] int fibnum */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setfib, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fibnum, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_ntp_adjtime_fill_uap(struct thread *td,
    struct ntp_adjtime_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _Inout_ struct timex * tp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ntp_adjtime, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->tp))
			return (EPROT);

		CHERI_CTOPTR(uap->tp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setgid_fill_uap(struct thread *td,
    struct setgid_args *uap)
{
	struct chericap tmpcap;

	/* [0] gid_t gid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setgid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->gid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_setegid_fill_uap(struct thread *td,
    struct setegid_args *uap)
{
	struct chericap tmpcap;

	/* [0] gid_t egid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setegid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->egid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_seteuid_fill_uap(struct thread *td,
    struct seteuid_args *uap)
{
	struct chericap tmpcap;

	/* [0] uid_t euid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_seteuid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->euid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_stat_fill_uap(struct thread *td,
    struct stat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_stat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_ struct stat * ub */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_stat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->ub))
			return (EPROT);

		CHERI_CTOPTR(uap->ub, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fstat_fill_uap(struct thread *td,
    struct fstat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fstat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] _Out_ struct stat * sb */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fstat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->sb))
			return (EPROT);

		CHERI_CTOPTR(uap->sb, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_lstat_fill_uap(struct thread *td,
    struct lstat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lstat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_ struct stat * ub */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lstat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->ub))
			return (EPROT);

		CHERI_CTOPTR(uap->ub, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_pathconf_fill_uap(struct thread *td,
    struct pathconf_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int name */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pathconf, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->name, CHERI_CR_CTEMP0);

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pathconf, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fpathconf_fill_uap(struct thread *td,
    struct fpathconf_args *uap)
{
	struct chericap tmpcap;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fpathconf, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] int name */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fpathconf, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->name, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_getrlimit_fill_uap(struct thread *td,
    struct __getrlimit_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] u_int which */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getrlimit, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->which, CHERI_CR_CTEMP0);

	/* [1] _Out_ struct rlimit * rlp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getrlimit, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->rlp))
			return (EPROT);

		CHERI_CTOPTR(uap->rlp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setrlimit_fill_uap(struct thread *td,
    struct __setrlimit_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] u_int which */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setrlimit, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->which, CHERI_CR_CTEMP0);

	/* [1] _In_ struct rlimit * rlp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setrlimit, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->rlp))
			return (EPROT);

		CHERI_CTOPTR(uap->rlp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getdirentries_fill_uap(struct thread *td,
    struct getdirentries_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getdirentries, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] u_int count */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getdirentries, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->count, CHERI_CR_CTEMP0);

	/* [1] _Out_writes_bytes_(count) char * buf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getdirentries, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->count)
			return (EPROT);

		CHERI_CTOPTR(uap->buf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _Out_ long * basep */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getdirentries, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->basep))
			return (EPROT);

		CHERI_CTOPTR(uap->basep, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS___sysctl_fill_uap(struct thread *td,
    struct sysctl_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] u_int namelen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___sysctl, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->namelen, CHERI_CR_CTEMP0);

	/* [5] void newlen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___sysctl, 5);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->newlen, CHERI_CR_CTEMP0);

	/* [0] _In_z_ int * name */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___sysctl, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->name))
			return (EPROT);

		CHERI_CTOPTR(uap->name, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _Inout_opt_ size_t * oldlenp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___sysctl, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->oldlenp, CHERI_CR_CTEMP0);
		if (uap->oldlenp != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->oldlenp))
			return (EPROT);

		CHERI_CTOPTR(uap->oldlenp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [4] _In_reads_bytes_opt_(newlen) void * new */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___sysctl, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->new, CHERI_CR_CTEMP0);
		if (uap->new != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->newlen)
			return (EPROT);

		CHERI_CTOPTR(uap->new, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Out_writes_bytes_opt_(*oldlenp) void * old */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___sysctl, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->old, CHERI_CR_CTEMP0);
		if (uap->old != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		if (uap->oldlenp == NULL)
			return (EINVAL);
		size_t reqlen;
		if (sizeof(uap->oldlenp) == 2)
			reqlen = fuword16(uap->oldlenp);
		else if (sizeof(uap->oldlenp) == 4)
			reqlen = fuword32(uap->oldlenp);
		else if (sizeof(uap->oldlenp) == 8)
			reqlen = fuword64(uap->oldlenp);
		else
			panic("unhandled dependant argument size %zu", sizeof(uap->oldlenp));
		reqlen = fuword(uap->oldlenp);
		if (reqlen == -1)
			return (EINVAL);
		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < reqlen)
			return (EPROT);

		CHERI_CTOPTR(uap->old, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_mlock_fill_uap(struct thread *td,
    struct mlock_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] size_t len */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mlock, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->len, CHERI_CR_CTEMP0);

	/* [0] _Pagerange_(len) const void * addr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mlock, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		CHERI_CGETLEN(base, CHERI_CR_CTEMP0);
		if (rounddown2(base + offset, PAGE_SIZE) < base)
			return (EPROT);
		size_t adjust;
		adjust = ((base + offset) & PAGE_MASK);
		length += adjust;
		if (length < roundup2(uap->len + adjust, PAGE_SIZE))
			return (EPROT);

		CHERI_CTOPTR(uap->addr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_munlock_fill_uap(struct thread *td,
    struct munlock_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] size_t len */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_munlock, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->len, CHERI_CR_CTEMP0);

	/* [0] _Pagerange_(len) const void * addr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_munlock, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		CHERI_CGETLEN(base, CHERI_CR_CTEMP0);
		if (rounddown2(base + offset, PAGE_SIZE) < base)
			return (EPROT);
		size_t adjust;
		adjust = ((base + offset) & PAGE_MASK);
		length += adjust;
		if (length < roundup2(uap->len + adjust, PAGE_SIZE))
			return (EPROT);

		CHERI_CTOPTR(uap->addr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_undelete_fill_uap(struct thread *td,
    struct undelete_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_undelete, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_futimes_fill_uap(struct thread *td,
    struct futimes_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_futimes, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] _In_reads_(2) struct timeval * tptr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_futimes, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->tptr) * 2))
			return (EPROT);

		CHERI_CTOPTR(uap->tptr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getpgid_fill_uap(struct thread *td,
    struct getpgid_args *uap)
{
	struct chericap tmpcap;

	/* [0] pid_t pid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getpgid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->pid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_poll_fill_uap(struct thread *td,
    struct poll_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] u_int nfds */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_poll, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nfds, CHERI_CR_CTEMP0);

	/* [2] int timeout */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_poll, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->timeout, CHERI_CR_CTEMP0);

	/* [0] _Inout_updates_(nfds) struct pollfd * fds */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_poll, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->fds) * uap->nfds))
			return (EPROT);

		CHERI_CTOPTR(uap->fds, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_semget_fill_uap(struct thread *td,
    struct semget_args *uap)
{
	struct chericap tmpcap;

	/* [0] key_t key */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_semget, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->key, CHERI_CR_CTEMP0);

	/* [1] int nsems */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_semget, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nsems, CHERI_CR_CTEMP0);

	/* [2] int semflg */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_semget, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->semflg, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_semop_fill_uap(struct thread *td,
    struct semop_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int semid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_semop, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->semid, CHERI_CR_CTEMP0);

	/* [2] u_int nsops */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_semop, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nsops, CHERI_CR_CTEMP0);

	/* [1] _In_reads_(nsops) struct sembuf * sops */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_semop, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->sops) * uap->nsops))
			return (EPROT);

		CHERI_CTOPTR(uap->sops, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_msgget_fill_uap(struct thread *td,
    struct msgget_args *uap)
{
	struct chericap tmpcap;

	/* [0] key_t key */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_msgget, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->key, CHERI_CR_CTEMP0);

	/* [1] int msgflg */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_msgget, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->msgflg, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_msgsnd_fill_uap(struct thread *td,
    struct msgsnd_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int msqid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_msgsnd, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->msqid, CHERI_CR_CTEMP0);

	/* [2] size_t msgsz */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_msgsnd, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->msgsz, CHERI_CR_CTEMP0);

	/* [3] int msgflg */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_msgsnd, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->msgflg, CHERI_CR_CTEMP0);

	/* [1] _In_reads_bytes_(msgsz) void * msgp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_msgsnd, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->msgsz)
			return (EPROT);

		CHERI_CTOPTR(uap->msgp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_msgrcv_fill_uap(struct thread *td,
    struct msgrcv_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int msqid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_msgrcv, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->msqid, CHERI_CR_CTEMP0);

	/* [2] size_t msgsz */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_msgrcv, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->msgsz, CHERI_CR_CTEMP0);

	/* [3] long msgtyp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_msgrcv, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->msgtyp, CHERI_CR_CTEMP0);

	/* [4] int msgflg */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_msgrcv, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->msgflg, CHERI_CR_CTEMP0);

	/* [1] _Out_writes_bytes_(msgsz) void * msgp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_msgrcv, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->msgsz)
			return (EPROT);

		CHERI_CTOPTR(uap->msgp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int	CHERIABI_SYS_cheriabi_shmat_fill_uap(struct thread *td,
    struct cheriabi_shmat_args *uap);

static inline int	CHERIABI_SYS_cheriabi_shmdt_fill_uap(struct thread *td,
    struct cheriabi_shmdt_args *uap);

static inline int
CHERIABI_SYS_shmget_fill_uap(struct thread *td,
    struct shmget_args *uap)
{
	struct chericap tmpcap;

	/* [0] key_t key */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_shmget, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->key, CHERI_CR_CTEMP0);

	/* [1] int size */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_shmget, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->size, CHERI_CR_CTEMP0);

	/* [2] int shmflg */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_shmget, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->shmflg, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_clock_gettime_fill_uap(struct thread *td,
    struct clock_gettime_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] clockid_t clock_id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_clock_gettime, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->clock_id, CHERI_CR_CTEMP0);

	/* [1] _Out_ struct timespec * tp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_clock_gettime, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->tp))
			return (EPROT);

		CHERI_CTOPTR(uap->tp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_clock_settime_fill_uap(struct thread *td,
    struct clock_settime_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] clockid_t clock_id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_clock_settime, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->clock_id, CHERI_CR_CTEMP0);

	/* [1] _In_ const struct timespec * tp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_clock_settime, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->tp))
			return (EPROT);

		CHERI_CTOPTR(uap->tp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_clock_getres_fill_uap(struct thread *td,
    struct clock_getres_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] clockid_t clock_id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_clock_getres, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->clock_id, CHERI_CR_CTEMP0);

	/* [1] _Out_ struct timespec * tp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_clock_getres, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->tp))
			return (EPROT);

		CHERI_CTOPTR(uap->tp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_ktimer_create_fill_uap(struct thread *td,
    struct cheriabi_ktimer_create_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] clockid_t clock_id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_ktimer_create, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->clock_id, CHERI_CR_CTEMP0);

	/* [1] _In_ struct sigevent_c * evp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_ktimer_create, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->evp))
			return (EPROT);

		CHERI_CTOPTR(uap->evp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Out_ int * timerid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_ktimer_create, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->timerid))
			return (EPROT);

		CHERI_CTOPTR(uap->timerid, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ktimer_delete_fill_uap(struct thread *td,
    struct ktimer_delete_args *uap)
{
	struct chericap tmpcap;

	/* [0] int timerid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ktimer_delete, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->timerid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_ktimer_settime_fill_uap(struct thread *td,
    struct ktimer_settime_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int timerid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ktimer_settime, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->timerid, CHERI_CR_CTEMP0);

	/* [1] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ktimer_settime, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [2] _In_ const struct itimerspec * value */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ktimer_settime, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->value))
			return (EPROT);

		CHERI_CTOPTR(uap->value, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _Out_opt_ struct itimerspec * ovalue */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ktimer_settime, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->ovalue, CHERI_CR_CTEMP0);
		if (uap->ovalue != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->ovalue))
			return (EPROT);

		CHERI_CTOPTR(uap->ovalue, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ktimer_gettime_fill_uap(struct thread *td,
    struct ktimer_gettime_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int timerid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ktimer_gettime, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->timerid, CHERI_CR_CTEMP0);

	/* [1] _Out_ struct itimerspec * value */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ktimer_gettime, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->value))
			return (EPROT);

		CHERI_CTOPTR(uap->value, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ktimer_getoverrun_fill_uap(struct thread *td,
    struct ktimer_getoverrun_args *uap)
{
	struct chericap tmpcap;

	/* [0] int timerid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ktimer_getoverrun, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->timerid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_nanosleep_fill_uap(struct thread *td,
    struct nanosleep_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ const struct timespec * rqtp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_nanosleep, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->rqtp))
			return (EPROT);

		CHERI_CTOPTR(uap->rqtp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_opt_ struct timespec * rmtp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_nanosleep, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->rmtp, CHERI_CR_CTEMP0);
		if (uap->rmtp != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->rmtp))
			return (EPROT);

		CHERI_CTOPTR(uap->rmtp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ffclock_getcounter_fill_uap(struct thread *td,
    struct ffclock_getcounter_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _Out_ ffcounter * ffcount */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ffclock_getcounter, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->ffcount))
			return (EPROT);

		CHERI_CTOPTR(uap->ffcount, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ffclock_setestimate_fill_uap(struct thread *td,
    struct ffclock_setestimate_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ struct ffclock_estimate * cest */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ffclock_setestimate, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->cest))
			return (EPROT);

		CHERI_CTOPTR(uap->cest, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ffclock_getestimate_fill_uap(struct thread *td,
    struct ffclock_getestimate_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _Out_ struct ffclock_estimate * cest */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ffclock_getestimate, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->cest))
			return (EPROT);

		CHERI_CTOPTR(uap->cest, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_clock_getcpuclockid2_fill_uap(struct thread *td,
    struct clock_getcpuclockid2_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] id_t id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_clock_getcpuclockid2, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->id, CHERI_CR_CTEMP0);

	/* [1] int which */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_clock_getcpuclockid2, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->which, CHERI_CR_CTEMP0);

	/* [2] _Out_ clockid_t * clock_id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_clock_getcpuclockid2, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->clock_id))
			return (EPROT);

		CHERI_CTOPTR(uap->clock_id, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ntp_gettime_fill_uap(struct thread *td,
    struct ntp_gettime_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _Out_ struct ntptimeval * ntvp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ntp_gettime, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->ntvp))
			return (EPROT);

		CHERI_CTOPTR(uap->ntvp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_minherit_fill_uap(struct thread *td,
    struct minherit_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] size_t len */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_minherit, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->len, CHERI_CR_CTEMP0);

	/* [2] int inherit */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_minherit, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->inherit, CHERI_CR_CTEMP0);

	/* [0] _Pagerange_(len) void * addr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_minherit, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		CHERI_CGETLEN(base, CHERI_CR_CTEMP0);
		if (rounddown2(base + offset, PAGE_SIZE) < base)
			return (EPROT);
		size_t adjust;
		adjust = ((base + offset) & PAGE_MASK);
		length += adjust;
		if (length < roundup2(uap->len + adjust, PAGE_SIZE))
			return (EPROT);

		CHERI_CTOPTR(uap->addr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_rfork_fill_uap(struct thread *td,
    struct rfork_args *uap)
{
	struct chericap tmpcap;

	/* [0] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rfork, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_openbsd_poll_fill_uap(struct thread *td,
    struct openbsd_poll_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] u_int nfds */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_openbsd_poll, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nfds, CHERI_CR_CTEMP0);

	/* [2] int timeout */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_openbsd_poll, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->timeout, CHERI_CR_CTEMP0);

	/* [0] _Inout_updates_(nfds) struct pollfd * fds */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_openbsd_poll, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->fds) * uap->nfds))
			return (EPROT);

		CHERI_CTOPTR(uap->fds, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_lchown_fill_uap(struct thread *td,
    struct lchown_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int uid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lchown, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->uid, CHERI_CR_CTEMP0);

	/* [2] int gid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lchown, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->gid, CHERI_CR_CTEMP0);

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lchown, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_aio_read_fill_uap(struct thread *td,
    struct cheriabi_aio_read_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _Inout_ struct aiocb_c * aiocbp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_read, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->aiocbp))
			return (EPROT);

		CHERI_CTOPTR(uap->aiocbp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_aio_write_fill_uap(struct thread *td,
    struct cheriabi_aio_write_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _Inout_ struct aiocb_c * aiocbp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_write, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->aiocbp))
			return (EPROT);

		CHERI_CTOPTR(uap->aiocbp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_lio_listio_fill_uap(struct thread *td,
    struct cheriabi_lio_listio_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int mode */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_lio_listio, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->mode, CHERI_CR_CTEMP0);

	/* [2] int nent */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_lio_listio, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nent, CHERI_CR_CTEMP0);

	/* [1] _Inout_updates_(nent) struct aiocb_c *const * acb_list */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_lio_listio, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->acb_list) * uap->nent))
			return (EPROT);

		CHERI_CTOPTR(uap->acb_list, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _In_opt_ struct sigevent_c * sig */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_lio_listio, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->sig, CHERI_CR_CTEMP0);
		if (uap->sig != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->sig))
			return (EPROT);

		CHERI_CTOPTR(uap->sig, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getdents_fill_uap(struct thread *td,
    struct getdents_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getdents, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] size_t count */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getdents, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->count, CHERI_CR_CTEMP0);

	/* [1] _Out_writes_bytes_(count) char * buf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getdents, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->count)
			return (EPROT);

		CHERI_CTOPTR(uap->buf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_lchmod_fill_uap(struct thread *td,
    struct lchmod_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] mode_t mode */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lchmod, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->mode, CHERI_CR_CTEMP0);

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lchmod, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_netbsd_lchown_fill_uap(struct thread *td,
    struct lchown_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] uid_t uid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_netbsd_lchown, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->uid, CHERI_CR_CTEMP0);

	/* [2] gid_t gid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_netbsd_lchown, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->gid, CHERI_CR_CTEMP0);

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_netbsd_lchown, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_lutimes_fill_uap(struct thread *td,
    struct lutimes_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lutimes, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _In_ struct timeval * tptr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lutimes, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->tptr))
			return (EPROT);

		CHERI_CTOPTR(uap->tptr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_netbsd_msync_fill_uap(struct thread *td,
    struct msync_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] size_t len */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_netbsd_msync, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->len, CHERI_CR_CTEMP0);

	/* [2] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_netbsd_msync, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [0] _Pagerange_(len) void * addr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_netbsd_msync, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		CHERI_CGETLEN(base, CHERI_CR_CTEMP0);
		if (rounddown2(base + offset, PAGE_SIZE) < base)
			return (EPROT);
		size_t adjust;
		adjust = ((base + offset) & PAGE_MASK);
		length += adjust;
		if (length < roundup2(uap->len + adjust, PAGE_SIZE))
			return (EPROT);

		CHERI_CTOPTR(uap->addr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_nstat_fill_uap(struct thread *td,
    struct nstat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_nstat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_ struct nstat * ub */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_nstat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->ub))
			return (EPROT);

		CHERI_CTOPTR(uap->ub, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_nfstat_fill_uap(struct thread *td,
    struct nfstat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_nfstat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] _Out_ struct nstat * sb */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_nfstat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->sb))
			return (EPROT);

		CHERI_CTOPTR(uap->sb, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_nlstat_fill_uap(struct thread *td,
    struct nlstat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_nlstat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_ struct nstat * ub */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_nlstat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->ub))
			return (EPROT);

		CHERI_CTOPTR(uap->ub, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_preadv_fill_uap(struct thread *td,
    struct cheriabi_preadv_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_preadv, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] u_int iovcnt */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_preadv, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->iovcnt, CHERI_CR_CTEMP0);

	/* [3] off_t offset */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_preadv, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->offset, CHERI_CR_CTEMP0);

	/* [1] _In_reads_(iovcnt) struct iovec_c * iovp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_preadv, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->iovp) * uap->iovcnt))
			return (EPROT);

		CHERI_CTOPTR(uap->iovp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_pwritev_fill_uap(struct thread *td,
    struct cheriabi_pwritev_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_pwritev, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] u_int iovcnt */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_pwritev, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->iovcnt, CHERI_CR_CTEMP0);

	/* [3] off_t offset */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_pwritev, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->offset, CHERI_CR_CTEMP0);

	/* [1] _In_reads_(iovcnt) struct iovec_c * iovp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_pwritev, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->iovp) * uap->iovcnt))
			return (EPROT);

		CHERI_CTOPTR(uap->iovp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fhopen_fill_uap(struct thread *td,
    struct fhopen_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fhopen, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [0] _In_ const struct fhandle * u_fhp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fhopen, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->u_fhp))
			return (EPROT);

		CHERI_CTOPTR(uap->u_fhp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fhstat_fill_uap(struct thread *td,
    struct fhstat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ const struct fhandle * u_fhp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fhstat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->u_fhp))
			return (EPROT);

		CHERI_CTOPTR(uap->u_fhp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_ struct stat * sb */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fhstat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->sb))
			return (EPROT);

		CHERI_CTOPTR(uap->sb, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_modnext_fill_uap(struct thread *td,
    struct modnext_args *uap)
{
	struct chericap tmpcap;

	/* [0] int modid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_modnext, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->modid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_modstat_fill_uap(struct thread *td,
    struct modstat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int modid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_modstat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->modid, CHERI_CR_CTEMP0);

	/* [1] _Out_ struct module_stat * stat */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_modstat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->stat))
			return (EPROT);

		CHERI_CTOPTR(uap->stat, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_modfnext_fill_uap(struct thread *td,
    struct modfnext_args *uap)
{
	struct chericap tmpcap;

	/* [0] int modid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_modfnext, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->modid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_modfind_fill_uap(struct thread *td,
    struct modfind_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ const char * name */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_modfind, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->name))
			return (EPROT);

		CHERI_CTOPTR(uap->name, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_kldload_fill_uap(struct thread *td,
    struct kldload_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ const char * file */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kldload, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->file))
			return (EPROT);

		CHERI_CTOPTR(uap->file, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_kldunload_fill_uap(struct thread *td,
    struct kldunload_args *uap)
{
	struct chericap tmpcap;

	/* [0] int fileid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kldunload, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fileid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_kldfind_fill_uap(struct thread *td,
    struct kldfind_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ const char * file */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kldfind, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->file))
			return (EPROT);

		CHERI_CTOPTR(uap->file, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_kldnext_fill_uap(struct thread *td,
    struct kldnext_args *uap)
{
	struct chericap tmpcap;

	/* [0] int fileid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kldnext, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fileid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_kldstat_fill_uap(struct thread *td,
    struct kldstat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fileid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kldstat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fileid, CHERI_CR_CTEMP0);

	/* [1] _Out_ struct kld_file_stat * stat */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kldstat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->stat))
			return (EPROT);

		CHERI_CTOPTR(uap->stat, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_kldfirstmod_fill_uap(struct thread *td,
    struct kldfirstmod_args *uap)
{
	struct chericap tmpcap;

	/* [0] int fileid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kldfirstmod, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fileid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_getsid_fill_uap(struct thread *td,
    struct getsid_args *uap)
{
	struct chericap tmpcap;

	/* [0] pid_t pid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getsid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->pid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_setresuid_fill_uap(struct thread *td,
    struct setresuid_args *uap)
{
	struct chericap tmpcap;

	/* [0] uid_t ruid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setresuid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->ruid, CHERI_CR_CTEMP0);

	/* [1] uid_t euid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setresuid, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->euid, CHERI_CR_CTEMP0);

	/* [2] uid_t suid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setresuid, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->suid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_setresgid_fill_uap(struct thread *td,
    struct setresgid_args *uap)
{
	struct chericap tmpcap;

	/* [0] gid_t rgid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setresgid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->rgid, CHERI_CR_CTEMP0);

	/* [1] gid_t egid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setresgid, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->egid, CHERI_CR_CTEMP0);

	/* [2] gid_t sgid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setresgid, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->sgid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_aio_return_fill_uap(struct thread *td,
    struct cheriabi_aio_return_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _Inout_ struct aiocb_c * aiocbp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_return, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->aiocbp))
			return (EPROT);

		CHERI_CTOPTR(uap->aiocbp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_aio_suspend_fill_uap(struct thread *td,
    struct cheriabi_aio_suspend_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int nent */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_suspend, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nent, CHERI_CR_CTEMP0);

	/* [0] _Inout_updates_(nent) struct aiocb_c *const * aiocbp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_suspend, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->aiocbp) * uap->nent))
			return (EPROT);

		CHERI_CTOPTR(uap->aiocbp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_opt_ const struct timespec * timeout */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_suspend, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->timeout, CHERI_CR_CTEMP0);
		if (uap->timeout != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->timeout))
			return (EPROT);

		CHERI_CTOPTR(uap->timeout, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_aio_cancel_fill_uap(struct thread *td,
    struct cheriabi_aio_cancel_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_cancel, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] _In_opt_ struct aiocb_c * aiocbp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_cancel, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->aiocbp, CHERI_CR_CTEMP0);
		if (uap->aiocbp != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->aiocbp))
			return (EPROT);

		CHERI_CTOPTR(uap->aiocbp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_aio_error_fill_uap(struct thread *td,
    struct cheriabi_aio_error_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ struct aiocb_c * aiocbp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_error, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->aiocbp))
			return (EPROT);

		CHERI_CTOPTR(uap->aiocbp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_mlockall_fill_uap(struct thread *td,
    struct mlockall_args *uap)
{
	struct chericap tmpcap;

	/* [0] int how */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mlockall, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->how, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS___getcwd_fill_uap(struct thread *td,
    struct __getcwd_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] u_int buflen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___getcwd, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->buflen, CHERI_CR_CTEMP0);

	/* [0] _In_z_ char * buf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___getcwd, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->buf))
			return (EPROT);

		CHERI_CTOPTR(uap->buf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sched_setparam_fill_uap(struct thread *td,
    struct sched_setparam_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] pid_t pid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sched_setparam, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->pid, CHERI_CR_CTEMP0);

	/* [1] _In_ const struct sched_param * param */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sched_setparam, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->param))
			return (EPROT);

		CHERI_CTOPTR(uap->param, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sched_getparam_fill_uap(struct thread *td,
    struct sched_getparam_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] pid_t pid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sched_getparam, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->pid, CHERI_CR_CTEMP0);

	/* [1] _Out_ struct sched_param * param */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sched_getparam, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->param))
			return (EPROT);

		CHERI_CTOPTR(uap->param, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sched_setscheduler_fill_uap(struct thread *td,
    struct sched_setscheduler_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] pid_t pid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sched_setscheduler, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->pid, CHERI_CR_CTEMP0);

	/* [1] int policy */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sched_setscheduler, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->policy, CHERI_CR_CTEMP0);

	/* [2] _In_ const struct sched_param * param */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sched_setscheduler, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->param))
			return (EPROT);

		CHERI_CTOPTR(uap->param, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sched_getscheduler_fill_uap(struct thread *td,
    struct sched_getscheduler_args *uap)
{
	struct chericap tmpcap;

	/* [0] pid_t pid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sched_getscheduler, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->pid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_sched_get_priority_max_fill_uap(struct thread *td,
    struct sched_get_priority_max_args *uap)
{
	struct chericap tmpcap;

	/* [0] int policy */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sched_get_priority_max, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->policy, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_sched_get_priority_min_fill_uap(struct thread *td,
    struct sched_get_priority_min_args *uap)
{
	struct chericap tmpcap;

	/* [0] int policy */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sched_get_priority_min, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->policy, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_sched_rr_get_interval_fill_uap(struct thread *td,
    struct sched_rr_get_interval_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] pid_t pid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sched_rr_get_interval, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->pid, CHERI_CR_CTEMP0);

	/* [1] _Out_ struct timespec * interval */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sched_rr_get_interval, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->interval))
			return (EPROT);

		CHERI_CTOPTR(uap->interval, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_utrace_fill_uap(struct thread *td,
    struct utrace_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] size_t len */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_utrace, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->len, CHERI_CR_CTEMP0);

	/* [0] _In_reads_bytes_(len) const void * addr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_utrace, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->len)
			return (EPROT);

		CHERI_CTOPTR(uap->addr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_kldsym_fill_uap(struct thread *td,
    struct cheriabi_kldsym_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fileid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_kldsym, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fileid, CHERI_CR_CTEMP0);

	/* [1] int cmd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_kldsym, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->cmd, CHERI_CR_CTEMP0);

	/* [2] _In_ struct kld_sym_lookup_c * data */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_kldsym, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->data))
			return (EPROT);

		CHERI_CTOPTR(uap->data, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_jail_fill_uap(struct thread *td,
    struct cheriabi_jail_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ struct jail_c * jail */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_jail, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->jail))
			return (EPROT);

		CHERI_CTOPTR(uap->jail, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sigprocmask_fill_uap(struct thread *td,
    struct sigprocmask_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int how */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sigprocmask, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->how, CHERI_CR_CTEMP0);

	/* [1] _In_opt_ const sigset_t * set */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sigprocmask, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->set, CHERI_CR_CTEMP0);
		if (uap->set != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->set))
			return (EPROT);

		CHERI_CTOPTR(uap->set, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Out_opt_ sigset_t * oset */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sigprocmask, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->oset, CHERI_CR_CTEMP0);
		if (uap->oset != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->oset))
			return (EPROT);

		CHERI_CTOPTR(uap->oset, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sigsuspend_fill_uap(struct thread *td,
    struct sigsuspend_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ const sigset_t * sigmask */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sigsuspend, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->sigmask))
			return (EPROT);

		CHERI_CTOPTR(uap->sigmask, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sigpending_fill_uap(struct thread *td,
    struct sigpending_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ sigset_t * set */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sigpending, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->set))
			return (EPROT);

		CHERI_CTOPTR(uap->set, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_sigtimedwait_fill_uap(struct thread *td,
    struct cheriabi_sigtimedwait_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ const sigset_t * set */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigtimedwait, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->set))
			return (EPROT);

		CHERI_CTOPTR(uap->set, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_opt_ struct siginfo_c * info */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigtimedwait, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->info, CHERI_CR_CTEMP0);
		if (uap->info != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->info))
			return (EPROT);

		CHERI_CTOPTR(uap->info, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_ const struct timespec * timeout */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigtimedwait, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->timeout))
			return (EPROT);

		CHERI_CTOPTR(uap->timeout, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_sigwaitinfo_fill_uap(struct thread *td,
    struct cheriabi_sigwaitinfo_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ const sigset_t * set */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigwaitinfo, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->set))
			return (EPROT);

		CHERI_CTOPTR(uap->set, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_opt_ struct siginfo_c * info */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigwaitinfo, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->info, CHERI_CR_CTEMP0);
		if (uap->info != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->info))
			return (EPROT);

		CHERI_CTOPTR(uap->info, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_get_file_fill_uap(struct thread *td,
    struct __acl_get_file_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] acl_type_t type */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_get_file, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->type, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_get_file, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Out_ struct acl * aclp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_get_file, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->aclp))
			return (EPROT);

		CHERI_CTOPTR(uap->aclp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_set_file_fill_uap(struct thread *td,
    struct __acl_set_file_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] acl_type_t type */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_set_file, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->type, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_set_file, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_ struct acl * aclp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_set_file, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->aclp))
			return (EPROT);

		CHERI_CTOPTR(uap->aclp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_get_fd_fill_uap(struct thread *td,
    struct __acl_get_fd_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int filedes */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_get_fd, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->filedes, CHERI_CR_CTEMP0);

	/* [1] acl_type_t type */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_get_fd, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->type, CHERI_CR_CTEMP0);

	/* [2] _Out_ struct acl * aclp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_get_fd, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->aclp))
			return (EPROT);

		CHERI_CTOPTR(uap->aclp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_set_fd_fill_uap(struct thread *td,
    struct __acl_set_fd_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int filedes */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_set_fd, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->filedes, CHERI_CR_CTEMP0);

	/* [1] acl_type_t type */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_set_fd, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->type, CHERI_CR_CTEMP0);

	/* [2] _In_ struct acl * aclp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_set_fd, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->aclp))
			return (EPROT);

		CHERI_CTOPTR(uap->aclp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_delete_file_fill_uap(struct thread *td,
    struct __acl_delete_file_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] acl_type_t type */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_delete_file, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->type, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_delete_file, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_delete_fd_fill_uap(struct thread *td,
    struct __acl_delete_fd_args *uap)
{
	struct chericap tmpcap;

	/* [0] int filedes */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_delete_fd, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->filedes, CHERI_CR_CTEMP0);

	/* [1] acl_type_t type */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_delete_fd, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->type, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS___acl_aclcheck_file_fill_uap(struct thread *td,
    struct __acl_aclcheck_file_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] acl_type_t type */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_aclcheck_file, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->type, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_aclcheck_file, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_ struct acl * aclp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_aclcheck_file, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->aclp))
			return (EPROT);

		CHERI_CTOPTR(uap->aclp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_aclcheck_fd_fill_uap(struct thread *td,
    struct __acl_aclcheck_fd_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int filedes */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_aclcheck_fd, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->filedes, CHERI_CR_CTEMP0);

	/* [1] acl_type_t type */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_aclcheck_fd, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->type, CHERI_CR_CTEMP0);

	/* [2] _In_ struct acl * aclp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_aclcheck_fd, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->aclp))
			return (EPROT);

		CHERI_CTOPTR(uap->aclp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattrctl_fill_uap(struct thread *td,
    struct extattrctl_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int cmd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattrctl, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->cmd, CHERI_CR_CTEMP0);

	/* [3] int attrnamespace */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattrctl, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->attrnamespace, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattrctl, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_z_opt_ const char * filename */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattrctl, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->filename, CHERI_CR_CTEMP0);
		if (uap->filename != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->filename))
			return (EPROT);

		CHERI_CTOPTR(uap->filename, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [4] _In_z_ const char * attrname */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattrctl, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->attrname))
			return (EPROT);

		CHERI_CTOPTR(uap->attrname, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_set_file_fill_uap(struct thread *td,
    struct extattr_set_file_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int attrnamespace */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_file, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->attrnamespace, CHERI_CR_CTEMP0);

	/* [4] size_t nbytes */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_file, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nbytes, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_file, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_z_ const char * attrname */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_file, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->attrname))
			return (EPROT);

		CHERI_CTOPTR(uap->attrname, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _In_reads_bytes_(nbytes) void * data */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_file, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->nbytes)
			return (EPROT);

		CHERI_CTOPTR(uap->data, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_get_file_fill_uap(struct thread *td,
    struct extattr_get_file_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int attrnamespace */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_file, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->attrnamespace, CHERI_CR_CTEMP0);

	/* [4] size_t nbytes */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_file, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nbytes, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_file, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_z_ const char * attrname */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_file, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->attrname))
			return (EPROT);

		CHERI_CTOPTR(uap->attrname, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _Out_writes_bytes_(nbytes) void * data */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_file, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->nbytes)
			return (EPROT);

		CHERI_CTOPTR(uap->data, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_delete_file_fill_uap(struct thread *td,
    struct extattr_delete_file_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int attrnamespace */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_delete_file, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->attrnamespace, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_delete_file, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_z_ const char * attrname */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_delete_file, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->attrname))
			return (EPROT);

		CHERI_CTOPTR(uap->attrname, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_aio_waitcomplete_fill_uap(struct thread *td,
    struct cheriabi_aio_waitcomplete_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _Outptr_result_maybenull_ struct aiocb_c ** aiocbp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_waitcomplete, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->aiocbp))
			return (EPROT);

		CHERI_CTOPTR(uap->aiocbp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _In_opt_ struct timespec * timeout */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_waitcomplete, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->timeout, CHERI_CR_CTEMP0);
		if (uap->timeout != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->timeout))
			return (EPROT);

		CHERI_CTOPTR(uap->timeout, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getresuid_fill_uap(struct thread *td,
    struct getresuid_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _Out_opt_ uid_t * ruid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getresuid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->ruid, CHERI_CR_CTEMP0);
		if (uap->ruid != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->ruid))
			return (EPROT);

		CHERI_CTOPTR(uap->ruid, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_opt_ uid_t * euid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getresuid, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->euid, CHERI_CR_CTEMP0);
		if (uap->euid != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->euid))
			return (EPROT);

		CHERI_CTOPTR(uap->euid, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Out_opt_ uid_t * suid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getresuid, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->suid, CHERI_CR_CTEMP0);
		if (uap->suid != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->suid))
			return (EPROT);

		CHERI_CTOPTR(uap->suid, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getresgid_fill_uap(struct thread *td,
    struct getresgid_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _Out_opt_ gid_t * rgid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getresgid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->rgid, CHERI_CR_CTEMP0);
		if (uap->rgid != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->rgid))
			return (EPROT);

		CHERI_CTOPTR(uap->rgid, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_opt_ gid_t * egid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getresgid, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->egid, CHERI_CR_CTEMP0);
		if (uap->egid != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->egid))
			return (EPROT);

		CHERI_CTOPTR(uap->egid, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Out_opt_ gid_t * sgid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getresgid, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->sgid, CHERI_CR_CTEMP0);
		if (uap->sgid != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->sgid))
			return (EPROT);

		CHERI_CTOPTR(uap->sgid, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_kevent_fill_uap(struct thread *td,
    struct cheriabi_kevent_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_kevent, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] int nchanges */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_kevent, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nchanges, CHERI_CR_CTEMP0);

	/* [4] int nevents */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_kevent, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nevents, CHERI_CR_CTEMP0);

	/* [1] _In_reads_opt_(nchanges) const struct kevent_c * changelist */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_kevent, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->changelist, CHERI_CR_CTEMP0);
		if (uap->changelist != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->changelist) * uap->nchanges))
			return (EPROT);

		CHERI_CTOPTR(uap->changelist, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _In_reads_opt_(nevents) struct kevent_c * eventlist */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_kevent, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->eventlist, CHERI_CR_CTEMP0);
		if (uap->eventlist != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->eventlist) * uap->nevents))
			return (EPROT);

		CHERI_CTOPTR(uap->eventlist, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [5] _In_opt_ const struct timespec * timeout */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_kevent, 5);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->timeout, CHERI_CR_CTEMP0);
		if (uap->timeout != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->timeout))
			return (EPROT);

		CHERI_CTOPTR(uap->timeout, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_set_fd_fill_uap(struct thread *td,
    struct extattr_set_fd_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_fd, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] int attrnamespace */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_fd, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->attrnamespace, CHERI_CR_CTEMP0);

	/* [4] size_t nbytes */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_fd, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nbytes, CHERI_CR_CTEMP0);

	/* [2] _In_z_ const char * attrname */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_fd, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->attrname))
			return (EPROT);

		CHERI_CTOPTR(uap->attrname, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _In_reads_bytes_(nbytes) void * data */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_fd, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->nbytes)
			return (EPROT);

		CHERI_CTOPTR(uap->data, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_get_fd_fill_uap(struct thread *td,
    struct extattr_get_fd_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_fd, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] int attrnamespace */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_fd, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->attrnamespace, CHERI_CR_CTEMP0);

	/* [4] size_t nbytes */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_fd, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nbytes, CHERI_CR_CTEMP0);

	/* [2] _In_z_ const char * attrname */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_fd, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->attrname))
			return (EPROT);

		CHERI_CTOPTR(uap->attrname, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _Out_writes_bytes_(nbytes) void * data */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_fd, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->nbytes)
			return (EPROT);

		CHERI_CTOPTR(uap->data, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_delete_fd_fill_uap(struct thread *td,
    struct extattr_delete_fd_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_delete_fd, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] int attrnamespace */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_delete_fd, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->attrnamespace, CHERI_CR_CTEMP0);

	/* [2] _In_z_ const char * attrname */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_delete_fd, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->attrname))
			return (EPROT);

		CHERI_CTOPTR(uap->attrname, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS___setugid_fill_uap(struct thread *td,
    struct __setugid_args *uap)
{
	struct chericap tmpcap;

	/* [0] int flag */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___setugid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flag, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_eaccess_fill_uap(struct thread *td,
    struct eaccess_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int amode */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_eaccess, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->amode, CHERI_CR_CTEMP0);

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_eaccess, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_nmount_fill_uap(struct thread *td,
    struct cheriabi_nmount_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] unsigned int iovcnt */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_nmount, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->iovcnt, CHERI_CR_CTEMP0);

	/* [2] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_nmount, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [0] _In_reads_(iovcnt) struct iovec_c * iovp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_nmount, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->iovp) * uap->iovcnt))
			return (EPROT);

		CHERI_CTOPTR(uap->iovp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_get_proc_fill_uap(struct thread *td,
    struct cheriabi___mac_get_proc_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ struct mac_c * mac_p */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_get_proc, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->mac_p))
			return (EPROT);

		CHERI_CTOPTR(uap->mac_p, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_set_proc_fill_uap(struct thread *td,
    struct cheriabi___mac_set_proc_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ struct mac_c * mac_p */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_set_proc, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->mac_p))
			return (EPROT);

		CHERI_CTOPTR(uap->mac_p, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_get_fd_fill_uap(struct thread *td,
    struct cheriabi___mac_get_fd_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_get_fd, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] _In_ struct mac_c * mac_p */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_get_fd, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->mac_p))
			return (EPROT);

		CHERI_CTOPTR(uap->mac_p, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_get_file_fill_uap(struct thread *td,
    struct cheriabi___mac_get_file_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ const char * path_p */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_get_file, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path_p))
			return (EPROT);

		CHERI_CTOPTR(uap->path_p, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _In_ struct mac_c * mac_p */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_get_file, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->mac_p))
			return (EPROT);

		CHERI_CTOPTR(uap->mac_p, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_set_fd_fill_uap(struct thread *td,
    struct cheriabi___mac_set_fd_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_set_fd, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] _In_ struct mac_c * mac_p */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_set_fd, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->mac_p))
			return (EPROT);

		CHERI_CTOPTR(uap->mac_p, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_set_file_fill_uap(struct thread *td,
    struct cheriabi___mac_set_file_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ const char * path_p */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_set_file, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path_p))
			return (EPROT);

		CHERI_CTOPTR(uap->path_p, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _In_ struct mac_c * mac_p */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_set_file, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->mac_p))
			return (EPROT);

		CHERI_CTOPTR(uap->mac_p, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_kenv_fill_uap(struct thread *td,
    struct kenv_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int what */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kenv, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->what, CHERI_CR_CTEMP0);

	/* [3] int len */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kenv, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->len, CHERI_CR_CTEMP0);

	/* [1] _In_z_ const char * name */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kenv, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->name))
			return (EPROT);

		CHERI_CTOPTR(uap->name, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Inout_ char * value */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kenv, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->value))
			return (EPROT);

		CHERI_CTOPTR(uap->value, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_lchflags_fill_uap(struct thread *td,
    struct lchflags_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] u_long flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lchflags, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lchflags, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_uuidgen_fill_uap(struct thread *td,
    struct uuidgen_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int count */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_uuidgen, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->count, CHERI_CR_CTEMP0);

	/* [0] _Out_writes_(count) struct uuid * store */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_uuidgen, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->store) * uap->count))
			return (EPROT);

		CHERI_CTOPTR(uap->store, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_sendfile_fill_uap(struct thread *td,
    struct cheriabi_sendfile_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sendfile, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] int s */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sendfile, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->s, CHERI_CR_CTEMP0);

	/* [2] off_t offset */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sendfile, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->offset, CHERI_CR_CTEMP0);

	/* [3] size_t nbytes */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sendfile, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nbytes, CHERI_CR_CTEMP0);

	/* [6] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sendfile, 6);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [4] _In_opt_ struct sf_hdtr_c * hdtr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sendfile, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->hdtr, CHERI_CR_CTEMP0);
		if (uap->hdtr != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->hdtr))
			return (EPROT);

		CHERI_CTOPTR(uap->hdtr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [5] _Out_opt_ off_t * sbytes */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sendfile, 5);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->sbytes, CHERI_CR_CTEMP0);
		if (uap->sbytes != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->sbytes))
			return (EPROT);

		CHERI_CTOPTR(uap->sbytes, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int	CHERIABI_SYS_mac_syscall_fill_uap(struct thread *td,
    struct mac_syscall_args *uap);

static inline int
CHERIABI_SYS_getfsstat_fill_uap(struct thread *td,
    struct getfsstat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] long bufsize */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getfsstat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->bufsize, CHERI_CR_CTEMP0);

	/* [2] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getfsstat, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [0] _Out_writes_bytes_opt_(bufsize) struct statfs * buf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getfsstat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->buf, CHERI_CR_CTEMP0);
		if (uap->buf != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->bufsize)
			return (EPROT);

		CHERI_CTOPTR(uap->buf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_statfs_fill_uap(struct thread *td,
    struct statfs_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_statfs, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_ struct statfs * buf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_statfs, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->buf))
			return (EPROT);

		CHERI_CTOPTR(uap->buf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fstatfs_fill_uap(struct thread *td,
    struct fstatfs_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fstatfs, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] _Out_ struct statfs * buf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fstatfs, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->buf))
			return (EPROT);

		CHERI_CTOPTR(uap->buf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fhstatfs_fill_uap(struct thread *td,
    struct fhstatfs_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ const struct fhandle * u_fhp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fhstatfs, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->u_fhp))
			return (EPROT);

		CHERI_CTOPTR(uap->u_fhp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_ struct statfs * buf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fhstatfs, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->buf))
			return (EPROT);

		CHERI_CTOPTR(uap->buf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_get_pid_fill_uap(struct thread *td,
    struct cheriabi___mac_get_pid_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] pid_t pid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_get_pid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->pid, CHERI_CR_CTEMP0);

	/* [1] _In_ struct mac_c * mac_p */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_get_pid, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->mac_p))
			return (EPROT);

		CHERI_CTOPTR(uap->mac_p, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_get_link_fill_uap(struct thread *td,
    struct cheriabi___mac_get_link_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ const char * path_p */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_get_link, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path_p))
			return (EPROT);

		CHERI_CTOPTR(uap->path_p, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _In_ struct mac_c * mac_p */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_get_link, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->mac_p))
			return (EPROT);

		CHERI_CTOPTR(uap->mac_p, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_set_link_fill_uap(struct thread *td,
    struct cheriabi___mac_set_link_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ const char * path_p */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_set_link, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path_p))
			return (EPROT);

		CHERI_CTOPTR(uap->path_p, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _In_ struct mac_c * mac_p */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_set_link, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->mac_p))
			return (EPROT);

		CHERI_CTOPTR(uap->mac_p, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_set_link_fill_uap(struct thread *td,
    struct extattr_set_link_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int attrnamespace */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_link, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->attrnamespace, CHERI_CR_CTEMP0);

	/* [4] size_t nbytes */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_link, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nbytes, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_link, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_z_ const char * attrname */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_link, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->attrname))
			return (EPROT);

		CHERI_CTOPTR(uap->attrname, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _In_reads_bytes_(nbytes) void * data */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_link, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->nbytes)
			return (EPROT);

		CHERI_CTOPTR(uap->data, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_get_link_fill_uap(struct thread *td,
    struct extattr_get_link_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int attrnamespace */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_link, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->attrnamespace, CHERI_CR_CTEMP0);

	/* [4] size_t nbytes */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_link, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nbytes, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_link, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_z_ const char * attrname */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_link, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->attrname))
			return (EPROT);

		CHERI_CTOPTR(uap->attrname, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _Out_writes_bytes_(nbytes) void * data */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_link, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->nbytes)
			return (EPROT);

		CHERI_CTOPTR(uap->data, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_delete_link_fill_uap(struct thread *td,
    struct extattr_delete_link_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int attrnamespace */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_delete_link, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->attrnamespace, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_delete_link, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_z_ const char * attrname */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_delete_link, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->attrname))
			return (EPROT);

		CHERI_CTOPTR(uap->attrname, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_execve_fill_uap(struct thread *td,
    struct cheriabi___mac_execve_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * fname */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_execve, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->fname))
			return (EPROT);

		CHERI_CTOPTR(uap->fname, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _In_ struct chericap * argv */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_execve, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->argv))
			return (EPROT);

		CHERI_CTOPTR(uap->argv, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_ struct chericap * envv */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_execve, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->envv))
			return (EPROT);

		CHERI_CTOPTR(uap->envv, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _In_ struct mac_c * mac_p */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_execve, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->mac_p))
			return (EPROT);

		CHERI_CTOPTR(uap->mac_p, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_sigaction_fill_uap(struct thread *td,
    struct cheriabi_sigaction_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int sig */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigaction, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->sig, CHERI_CR_CTEMP0);

	/* [1] _In_opt_ struct sigaction_c * act */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigaction, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->act, CHERI_CR_CTEMP0);
		if (uap->act != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->act))
			return (EPROT);

		CHERI_CTOPTR(uap->act, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Out_opt_ struct sigaction_c * oact */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigaction, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->oact, CHERI_CR_CTEMP0);
		if (uap->oact != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->oact))
			return (EPROT);

		CHERI_CTOPTR(uap->oact, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_sigreturn_fill_uap(struct thread *td,
    struct cheriabi_sigreturn_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ const struct ucontext_c * sigcntxp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigreturn, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->sigcntxp))
			return (EPROT);

		CHERI_CTOPTR(uap->sigcntxp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_getcontext_fill_uap(struct thread *td,
    struct cheriabi_getcontext_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _Out_ struct ucontext_c * ucp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_getcontext, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->ucp))
			return (EPROT);

		CHERI_CTOPTR(uap->ucp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_setcontext_fill_uap(struct thread *td,
    struct cheriabi_setcontext_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ const struct ucontext_c * ucp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_setcontext, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->ucp))
			return (EPROT);

		CHERI_CTOPTR(uap->ucp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_swapcontext_fill_uap(struct thread *td,
    struct cheriabi_swapcontext_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _Out_ struct ucontext_c * oucp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_swapcontext, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->oucp))
			return (EPROT);

		CHERI_CTOPTR(uap->oucp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _In_ const struct ucontext_c * ucp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_swapcontext, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->ucp))
			return (EPROT);

		CHERI_CTOPTR(uap->ucp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_swapoff_fill_uap(struct thread *td,
    struct swapoff_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ const char * name */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_swapoff, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->name))
			return (EPROT);

		CHERI_CTOPTR(uap->name, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_get_link_fill_uap(struct thread *td,
    struct __acl_get_link_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] acl_type_t type */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_get_link, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->type, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_get_link, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Out_ struct acl * aclp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_get_link, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->aclp))
			return (EPROT);

		CHERI_CTOPTR(uap->aclp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_set_link_fill_uap(struct thread *td,
    struct __acl_set_link_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] acl_type_t type */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_set_link, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->type, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_set_link, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_ struct acl * aclp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_set_link, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->aclp))
			return (EPROT);

		CHERI_CTOPTR(uap->aclp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_delete_link_fill_uap(struct thread *td,
    struct __acl_delete_link_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] acl_type_t type */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_delete_link, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->type, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_delete_link, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_aclcheck_link_fill_uap(struct thread *td,
    struct __acl_aclcheck_link_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] acl_type_t type */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_aclcheck_link, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->type, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_aclcheck_link, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_ struct acl * aclp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_aclcheck_link, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->aclp))
			return (EPROT);

		CHERI_CTOPTR(uap->aclp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sigwait_fill_uap(struct thread *td,
    struct sigwait_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ const sigset_t * set */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sigwait, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->set))
			return (EPROT);

		CHERI_CTOPTR(uap->set, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_ int * sig */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sigwait, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->sig))
			return (EPROT);

		CHERI_CTOPTR(uap->sig, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_thr_create_fill_uap(struct thread *td,
    struct cheriabi_thr_create_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [2] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_thr_create, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [0] _In_ ucontext_t * ctx */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_thr_create, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->ctx))
			return (EPROT);

		CHERI_CTOPTR(uap->ctx, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_ long * id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_thr_create, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->id))
			return (EPROT);

		CHERI_CTOPTR(uap->id, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_thr_exit_fill_uap(struct thread *td,
    struct thr_exit_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _Out_opt_ long * state */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_thr_exit, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->state, CHERI_CR_CTEMP0);
		if (uap->state != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->state))
			return (EPROT);

		CHERI_CTOPTR(uap->state, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_thr_self_fill_uap(struct thread *td,
    struct thr_self_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _Out_ long * id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_thr_self, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->id))
			return (EPROT);

		CHERI_CTOPTR(uap->id, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_thr_kill_fill_uap(struct thread *td,
    struct thr_kill_args *uap)
{
	struct chericap tmpcap;

	/* [0] long id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_thr_kill, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->id, CHERI_CR_CTEMP0);

	/* [1] int sig */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_thr_kill, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->sig, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_jail_attach_fill_uap(struct thread *td,
    struct jail_attach_args *uap)
{
	struct chericap tmpcap;

	/* [0] int jid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_jail_attach, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->jid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_extattr_list_fd_fill_uap(struct thread *td,
    struct extattr_list_fd_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_list_fd, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] int attrnamespace */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_list_fd, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->attrnamespace, CHERI_CR_CTEMP0);

	/* [3] size_t nbytes */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_list_fd, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nbytes, CHERI_CR_CTEMP0);

	/* [2] _Out_writes_bytes_opt_(nbytes) void * data */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_list_fd, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->data, CHERI_CR_CTEMP0);
		if (uap->data != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->nbytes)
			return (EPROT);

		CHERI_CTOPTR(uap->data, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_list_file_fill_uap(struct thread *td,
    struct extattr_list_file_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int attrnamespace */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_list_file, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->attrnamespace, CHERI_CR_CTEMP0);

	/* [3] size_t nbytes */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_list_file, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nbytes, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_list_file, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Out_writes_bytes_opt_(nbytes) void * data */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_list_file, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->data, CHERI_CR_CTEMP0);
		if (uap->data != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->nbytes)
			return (EPROT);

		CHERI_CTOPTR(uap->data, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_list_link_fill_uap(struct thread *td,
    struct extattr_list_link_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int attrnamespace */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_list_link, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->attrnamespace, CHERI_CR_CTEMP0);

	/* [3] size_t nbytes */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_list_link, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nbytes, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_list_link, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Out_writes_bytes_opt_(nbytes) void * data */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_list_link, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->data, CHERI_CR_CTEMP0);
		if (uap->data != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->nbytes)
			return (EPROT);

		CHERI_CTOPTR(uap->data, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ksem_timedwait_fill_uap(struct thread *td,
    struct ksem_timedwait_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] semid_t id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ksem_timedwait, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->id, CHERI_CR_CTEMP0);

	/* [1] _In_opt_ const struct timespec * abstime */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ksem_timedwait, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->abstime, CHERI_CR_CTEMP0);
		if (uap->abstime != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->abstime))
			return (EPROT);

		CHERI_CTOPTR(uap->abstime, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_thr_suspend_fill_uap(struct thread *td,
    struct thr_suspend_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_opt_ const struct timespec * timeout */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_thr_suspend, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->timeout, CHERI_CR_CTEMP0);
		if (uap->timeout != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->timeout))
			return (EPROT);

		CHERI_CTOPTR(uap->timeout, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_thr_wake_fill_uap(struct thread *td,
    struct thr_wake_args *uap)
{
	struct chericap tmpcap;

	/* [0] long id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_thr_wake, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->id, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_kldunloadf_fill_uap(struct thread *td,
    struct kldunloadf_args *uap)
{
	struct chericap tmpcap;

	/* [0] int fileid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kldunloadf, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fileid, CHERI_CR_CTEMP0);

	/* [1] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kldunloadf, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_audit_fill_uap(struct thread *td,
    struct audit_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] u_int length */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_audit, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->length, CHERI_CR_CTEMP0);

	/* [0] _In_reads_bytes_(length) const void * record */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_audit, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->length)
			return (EPROT);

		CHERI_CTOPTR(uap->record, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int	CHERIABI_SYS_auditon_fill_uap(struct thread *td,
    struct auditon_args *uap);

static inline int
CHERIABI_SYS_getauid_fill_uap(struct thread *td,
    struct getauid_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _Out_ uid_t * auid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getauid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->auid))
			return (EPROT);

		CHERI_CTOPTR(uap->auid, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setauid_fill_uap(struct thread *td,
    struct setauid_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ uid_t * auid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setauid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->auid))
			return (EPROT);

		CHERI_CTOPTR(uap->auid, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getaudit_fill_uap(struct thread *td,
    struct getaudit_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _Out_ struct auditinfo * auditinfo */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getaudit, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->auditinfo))
			return (EPROT);

		CHERI_CTOPTR(uap->auditinfo, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setaudit_fill_uap(struct thread *td,
    struct setaudit_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ struct auditinfo * auditinfo */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setaudit, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->auditinfo))
			return (EPROT);

		CHERI_CTOPTR(uap->auditinfo, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getaudit_addr_fill_uap(struct thread *td,
    struct getaudit_addr_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] u_int length */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getaudit_addr, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->length, CHERI_CR_CTEMP0);

	/* [0] _Out_writes_bytes_(length) struct auditinfo_addr * auditinfo_addr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getaudit_addr, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->length)
			return (EPROT);

		CHERI_CTOPTR(uap->auditinfo_addr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setaudit_addr_fill_uap(struct thread *td,
    struct setaudit_addr_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] u_int length */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setaudit_addr, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->length, CHERI_CR_CTEMP0);

	/* [0] _In_reads_bytes_(length) struct auditinfo_addr * auditinfo_addr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setaudit_addr, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->length)
			return (EPROT);

		CHERI_CTOPTR(uap->auditinfo_addr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_auditctl_fill_uap(struct thread *td,
    struct auditctl_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_auditctl, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int	CHERIABI_SYS__umtx_op_fill_uap(struct thread *td,
    struct _umtx_op_args *uap);

static inline int
CHERIABI_SYS_cheriabi_thr_new_fill_uap(struct thread *td,
    struct cheriabi_thr_new_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int param_size */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_thr_new, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->param_size, CHERI_CR_CTEMP0);

	/* [0] _In_ struct thr_param_c * param */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_thr_new, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->param))
			return (EPROT);

		CHERI_CTOPTR(uap->param, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int	CHERIABI_SYS_cheriabi_sigqueue_fill_uap(struct thread *td,
    struct cheriabi_sigqueue_args *uap);

static inline int
CHERIABI_SYS_kmq_open_fill_uap(struct thread *td,
    struct kmq_open_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_open, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [2] mode_t mode */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_open, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->mode, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_open, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _In_opt_ const struct mq_attr * attr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_open, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->attr, CHERI_CR_CTEMP0);
		if (uap->attr != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->attr))
			return (EPROT);

		CHERI_CTOPTR(uap->attr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_kmq_setattr_fill_uap(struct thread *td,
    struct kmq_setattr_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int mqd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_setattr, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->mqd, CHERI_CR_CTEMP0);

	/* [1] _In_opt_ const struct mq_attr * attr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_setattr, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->attr, CHERI_CR_CTEMP0);
		if (uap->attr != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->attr))
			return (EPROT);

		CHERI_CTOPTR(uap->attr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Out_opt_ struct mq_attr * oattr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_setattr, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->oattr, CHERI_CR_CTEMP0);
		if (uap->oattr != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->oattr))
			return (EPROT);

		CHERI_CTOPTR(uap->oattr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_kmq_timedreceive_fill_uap(struct thread *td,
    struct kmq_timedreceive_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int mqd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_timedreceive, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->mqd, CHERI_CR_CTEMP0);

	/* [2] size_t msg_len */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_timedreceive, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->msg_len, CHERI_CR_CTEMP0);

	/* [1] _Out_writes_bytes_(msg_len) char * msg_ptr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_timedreceive, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->msg_len)
			return (EPROT);

		CHERI_CTOPTR(uap->msg_ptr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _Out_opt_ unsigned * msg_prio */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_timedreceive, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->msg_prio, CHERI_CR_CTEMP0);
		if (uap->msg_prio != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->msg_prio))
			return (EPROT);

		CHERI_CTOPTR(uap->msg_prio, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [4] _In_opt_ const struct timespec * abs_timeout */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_timedreceive, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->abs_timeout, CHERI_CR_CTEMP0);
		if (uap->abs_timeout != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->abs_timeout))
			return (EPROT);

		CHERI_CTOPTR(uap->abs_timeout, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_kmq_timedsend_fill_uap(struct thread *td,
    struct kmq_timedsend_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int mqd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_timedsend, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->mqd, CHERI_CR_CTEMP0);

	/* [2] size_t msg_len */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_timedsend, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->msg_len, CHERI_CR_CTEMP0);

	/* [3] unsigned msg_prio */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_timedsend, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->msg_prio, CHERI_CR_CTEMP0);

	/* [1] _In_reads_bytes_(msg_len) const char * msg_ptr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_timedsend, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->msg_len)
			return (EPROT);

		CHERI_CTOPTR(uap->msg_ptr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [4] _In_opt_ const struct timespec * abs_timeout */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_timedsend, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->abs_timeout, CHERI_CR_CTEMP0);
		if (uap->abs_timeout != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->abs_timeout))
			return (EPROT);

		CHERI_CTOPTR(uap->abs_timeout, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_kmq_notify_fill_uap(struct thread *td,
    struct cheriabi_kmq_notify_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int mqd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_kmq_notify, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->mqd, CHERI_CR_CTEMP0);

	/* [1] _In_opt_ const struct sigevent_c * sigev */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_kmq_notify, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->sigev, CHERI_CR_CTEMP0);
		if (uap->sigev != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->sigev))
			return (EPROT);

		CHERI_CTOPTR(uap->sigev, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_kmq_unlink_fill_uap(struct thread *td,
    struct kmq_unlink_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_unlink, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_abort2_fill_uap(struct thread *td,
    struct cheriabi_abort2_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int nargs */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_abort2, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nargs, CHERI_CR_CTEMP0);

	/* [0] _In_z_ const char * why */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_abort2, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->why))
			return (EPROT);

		CHERI_CTOPTR(uap->why, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_reads_(nargs) struct chericap * args */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_abort2, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->args) * uap->nargs))
			return (EPROT);

		CHERI_CTOPTR(uap->args, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_thr_set_name_fill_uap(struct thread *td,
    struct thr_set_name_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] long id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_thr_set_name, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->id, CHERI_CR_CTEMP0);

	/* [1] _In_z_ const char * name */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_thr_set_name, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->name))
			return (EPROT);

		CHERI_CTOPTR(uap->name, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_aio_fsync_fill_uap(struct thread *td,
    struct cheriabi_aio_fsync_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int op */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_fsync, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->op, CHERI_CR_CTEMP0);

	/* [1] _In_ struct aiocb_c * aiocbp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_fsync, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->aiocbp))
			return (EPROT);

		CHERI_CTOPTR(uap->aiocbp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_rtprio_thread_fill_uap(struct thread *td,
    struct rtprio_thread_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int function */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rtprio_thread, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->function, CHERI_CR_CTEMP0);

	/* [1] lwpid_t lwpid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rtprio_thread, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->lwpid, CHERI_CR_CTEMP0);

	/* [2] _Inout_ struct rtprio * rtp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rtprio_thread, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->rtp))
			return (EPROT);

		CHERI_CTOPTR(uap->rtp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sctp_peeloff_fill_uap(struct thread *td,
    struct sctp_peeloff_args *uap)
{
	struct chericap tmpcap;

	/* [0] int sd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sctp_peeloff, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->sd, CHERI_CR_CTEMP0);

	/* [1] uint32_t name */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sctp_peeloff, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->name, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_sctp_generic_sendmsg_fill_uap(struct thread *td,
    struct sctp_generic_sendmsg_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int sd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sctp_generic_sendmsg, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->sd, CHERI_CR_CTEMP0);

	/* [2] int mlen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sctp_generic_sendmsg, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->mlen, CHERI_CR_CTEMP0);

	/* [4] socklen_t tolen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sctp_generic_sendmsg, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->tolen, CHERI_CR_CTEMP0);

	/* [6] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sctp_generic_sendmsg, 6);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [1] _In_reads_bytes_(mlen) caddr_t msg */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sctp_generic_sendmsg, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->mlen)
			return (EPROT);

		CHERI_CTOPTR(uap->msg, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _In_reads_bytes_(tolen) caddr_t to */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sctp_generic_sendmsg, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->tolen)
			return (EPROT);

		CHERI_CTOPTR(uap->to, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [5] _In_opt_ struct sctp_sndrcvinfo * sinfo */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sctp_generic_sendmsg, 5);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->sinfo, CHERI_CR_CTEMP0);
		if (uap->sinfo != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->sinfo))
			return (EPROT);

		CHERI_CTOPTR(uap->sinfo, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_sctp_generic_sendmsg_iov_fill_uap(struct thread *td,
    struct cheriabi_sctp_generic_sendmsg_iov_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int sd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_sendmsg_iov, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->sd, CHERI_CR_CTEMP0);

	/* [2] int iovlen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_sendmsg_iov, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->iovlen, CHERI_CR_CTEMP0);

	/* [4] socklen_t tolen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_sendmsg_iov, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->tolen, CHERI_CR_CTEMP0);

	/* [6] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_sendmsg_iov, 6);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [1] _In_reads_(iovlen) struct iovec_c * iov */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_sendmsg_iov, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->iov) * uap->iovlen))
			return (EPROT);

		CHERI_CTOPTR(uap->iov, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _In_reads_bytes(tolen) caddr_t to */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_sendmsg_iov, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->to) * uap->tolen))
			return (EPROT);

		CHERI_CTOPTR(uap->to, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [5] _In_opt_ struct sctp_sndrcvinfo * sinfo */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_sendmsg_iov, 5);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->sinfo, CHERI_CR_CTEMP0);
		if (uap->sinfo != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->sinfo))
			return (EPROT);

		CHERI_CTOPTR(uap->sinfo, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_sctp_generic_recvmsg_fill_uap(struct thread *td,
    struct cheriabi_sctp_generic_recvmsg_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int sd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_recvmsg, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->sd, CHERI_CR_CTEMP0);

	/* [2] int iovlen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_recvmsg, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->iovlen, CHERI_CR_CTEMP0);

	/* [1] _In_reads(iovlen) struct iovec_c * iov */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_recvmsg, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->iov) * uap->iovlen))
			return (EPROT);

		CHERI_CTOPTR(uap->iov, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [4] _Out_ socklen_t * fromlenaddr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_recvmsg, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->fromlenaddr))
			return (EPROT);

		CHERI_CTOPTR(uap->fromlenaddr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [5] _In_opt_ struct sctp_sndrcvinfo * sinfo */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_recvmsg, 5);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->sinfo, CHERI_CR_CTEMP0);
		if (uap->sinfo != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->sinfo))
			return (EPROT);

		CHERI_CTOPTR(uap->sinfo, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [6] _Out_opt_ int * msg_flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_recvmsg, 6);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->msg_flags, CHERI_CR_CTEMP0);
		if (uap->msg_flags != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->msg_flags))
			return (EPROT);

		CHERI_CTOPTR(uap->msg_flags, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _Out_writes_bytes_(*fromlenaddr) struct sockaddr * from */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_recvmsg, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		if (uap->fromlenaddr == NULL)
			return (EINVAL);
		size_t reqlen;
		if (sizeof(uap->fromlenaddr) == 2)
			reqlen = fuword16(uap->fromlenaddr);
		else if (sizeof(uap->fromlenaddr) == 4)
			reqlen = fuword32(uap->fromlenaddr);
		else if (sizeof(uap->fromlenaddr) == 8)
			reqlen = fuword64(uap->fromlenaddr);
		else
			panic("unhandled dependant argument size %zu", sizeof(uap->fromlenaddr));
		reqlen = fuword(uap->fromlenaddr);
		if (reqlen == -1)
			return (EINVAL);
		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < reqlen)
			return (EPROT);

		CHERI_CTOPTR(uap->from, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_pread_fill_uap(struct thread *td,
    struct pread_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pread, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] size_t nbyte */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pread, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nbyte, CHERI_CR_CTEMP0);

	/* [3] off_t offset */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pread, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->offset, CHERI_CR_CTEMP0);

	/* [1] _Out_writes_bytes_(nbyte) void * buf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pread, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->nbyte)
			return (EPROT);

		CHERI_CTOPTR(uap->buf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_pwrite_fill_uap(struct thread *td,
    struct pwrite_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pwrite, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] size_t nbyte */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pwrite, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nbyte, CHERI_CR_CTEMP0);

	/* [3] off_t offset */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pwrite, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->offset, CHERI_CR_CTEMP0);

	/* [1] _Out_writes_bytes_(nbyte) const void * buf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pwrite, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->nbyte)
			return (EPROT);

		CHERI_CTOPTR(uap->buf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_mmap_fill_uap(struct thread *td,
    struct cheriabi_mmap_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] size_t len */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_mmap, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->len, CHERI_CR_CTEMP0);

	/* [2] int prot */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_mmap, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->prot, CHERI_CR_CTEMP0);

	/* [3] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_mmap, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [4] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_mmap, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [5] off_t pos */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_mmap, 5);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->pos, CHERI_CR_CTEMP0);

	/* [0] _Pagerange_opt_(len) caddr_t addr */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_mmap, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->addr, CHERI_CR_CTEMP0);
		if (uap->addr != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		CHERI_CGETLEN(base, CHERI_CR_CTEMP0);
		if (rounddown2(base + offset, PAGE_SIZE) < base)
			return (EPROT);
		size_t adjust;
		adjust = ((base + offset) & PAGE_MASK);
		length += adjust;
		if (length < roundup2(uap->len + adjust, PAGE_SIZE))
			return (EPROT);

		CHERI_CTOPTR(uap->addr, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_lseek_fill_uap(struct thread *td,
    struct lseek_args *uap)
{
	struct chericap tmpcap;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lseek, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] off_t offset */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lseek, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->offset, CHERI_CR_CTEMP0);

	/* [2] int whence */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lseek, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->whence, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_truncate_fill_uap(struct thread *td,
    struct truncate_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] off_t length */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_truncate, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->length, CHERI_CR_CTEMP0);

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_truncate, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ftruncate_fill_uap(struct thread *td,
    struct ftruncate_args *uap)
{
	struct chericap tmpcap;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ftruncate, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] off_t length */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ftruncate, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->length, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_thr_kill2_fill_uap(struct thread *td,
    struct thr_kill2_args *uap)
{
	struct chericap tmpcap;

	/* [0] pid_t pid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_thr_kill2, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->pid, CHERI_CR_CTEMP0);

	/* [1] long id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_thr_kill2, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->id, CHERI_CR_CTEMP0);

	/* [2] int sig */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_thr_kill2, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->sig, CHERI_CR_CTEMP0);

	return (0);
}

static inline int	CHERIABI_SYS_shm_open_fill_uap(struct thread *td,
    struct shm_open_args *uap);

static inline int
CHERIABI_SYS_shm_unlink_fill_uap(struct thread *td,
    struct shm_unlink_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_shm_unlink, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cpuset_fill_uap(struct thread *td,
    struct cpuset_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _Out_ cpusetid_t * setid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->setid))
			return (EPROT);

		CHERI_CTOPTR(uap->setid, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cpuset_setid_fill_uap(struct thread *td,
    struct cpuset_setid_args *uap)
{
	struct chericap tmpcap;

	/* [0] cpuwhich_t which */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_setid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->which, CHERI_CR_CTEMP0);

	/* [1] id_t id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_setid, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->id, CHERI_CR_CTEMP0);

	/* [2] cpusetid_t setid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_setid, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->setid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_cpuset_getid_fill_uap(struct thread *td,
    struct cpuset_getid_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] cpulevel_t level */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_getid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->level, CHERI_CR_CTEMP0);

	/* [1] cpuwhich_t which */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_getid, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->which, CHERI_CR_CTEMP0);

	/* [2] it_t id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_getid, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->id, CHERI_CR_CTEMP0);

	/* [3] _Out_ cpusetid_t * setid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_getid, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->setid))
			return (EPROT);

		CHERI_CTOPTR(uap->setid, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cpuset_getaffinity_fill_uap(struct thread *td,
    struct cpuset_getaffinity_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] cpulevel_t level */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_getaffinity, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->level, CHERI_CR_CTEMP0);

	/* [1] cpuwhich_t which */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_getaffinity, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->which, CHERI_CR_CTEMP0);

	/* [2] id_t id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_getaffinity, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->id, CHERI_CR_CTEMP0);

	/* [3] size_t cpusetsize */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_getaffinity, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->cpusetsize, CHERI_CR_CTEMP0);

	/* [4] _Out_ cpuset_t * mask */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_getaffinity, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->mask))
			return (EPROT);

		CHERI_CTOPTR(uap->mask, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cpuset_setaffinity_fill_uap(struct thread *td,
    struct cpuset_setaffinity_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] cpulevel_t level */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_setaffinity, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->level, CHERI_CR_CTEMP0);

	/* [1] cpuwhich_t which */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_setaffinity, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->which, CHERI_CR_CTEMP0);

	/* [2] id_t id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_setaffinity, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->id, CHERI_CR_CTEMP0);

	/* [3] size_t cpusetsize */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_setaffinity, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->cpusetsize, CHERI_CR_CTEMP0);

	/* [4] _Out_ const cpuset_t * mask */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_setaffinity, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->mask))
			return (EPROT);

		CHERI_CTOPTR(uap->mask, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_faccessat_fill_uap(struct thread *td,
    struct faccessat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_faccessat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] int amode */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_faccessat, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->amode, CHERI_CR_CTEMP0);

	/* [3] int flag */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_faccessat, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flag, CHERI_CR_CTEMP0);

	/* [1] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_faccessat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fchmodat_fill_uap(struct thread *td,
    struct fchmodat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fchmodat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] mode_t mode */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fchmodat, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->mode, CHERI_CR_CTEMP0);

	/* [3] int flag */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fchmodat, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flag, CHERI_CR_CTEMP0);

	/* [1] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fchmodat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fchownat_fill_uap(struct thread *td,
    struct fchownat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fchownat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] uid_t uid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fchownat, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->uid, CHERI_CR_CTEMP0);

	/* [3] gid_t gid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fchownat, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->gid, CHERI_CR_CTEMP0);

	/* [4] int flag */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fchownat, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flag, CHERI_CR_CTEMP0);

	/* [1] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fchownat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_fexecve_fill_uap(struct thread *td,
    struct cheriabi_fexecve_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_fexecve, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] _In_ struct chericap * argv */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_fexecve, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->argv))
			return (EPROT);

		CHERI_CTOPTR(uap->argv, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_ struct chericap * envv */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_fexecve, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->envv))
			return (EPROT);

		CHERI_CTOPTR(uap->envv, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fstatat_fill_uap(struct thread *td,
    struct fstatat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fstatat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [3] int flag */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fstatat, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flag, CHERI_CR_CTEMP0);

	/* [1] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fstatat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Out_ struct stat * buf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fstatat, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->buf))
			return (EPROT);

		CHERI_CTOPTR(uap->buf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_futimesat_fill_uap(struct thread *td,
    struct futimesat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_futimesat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_futimesat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_reads_(2) struct timeval * times */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_futimesat, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->times) * 2))
			return (EPROT);

		CHERI_CTOPTR(uap->times, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_linkat_fill_uap(struct thread *td,
    struct linkat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd1 */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_linkat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd1, CHERI_CR_CTEMP0);

	/* [2] int fd2 */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_linkat, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd2, CHERI_CR_CTEMP0);

	/* [4] int flag */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_linkat, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flag, CHERI_CR_CTEMP0);

	/* [1] _In_z_ char * path1 */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_linkat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path1))
			return (EPROT);

		CHERI_CTOPTR(uap->path1, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _In_z_ char * path2 */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_linkat, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path2))
			return (EPROT);

		CHERI_CTOPTR(uap->path2, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_mkdirat_fill_uap(struct thread *td,
    struct mkdirat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mkdirat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] mode_t mode */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mkdirat, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->mode, CHERI_CR_CTEMP0);

	/* [1] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mkdirat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_mkfifoat_fill_uap(struct thread *td,
    struct mkfifoat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mkfifoat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] mode_t mode */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mkfifoat, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->mode, CHERI_CR_CTEMP0);

	/* [1] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mkfifoat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_mknodat_fill_uap(struct thread *td,
    struct mknodat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mknodat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] mode_t mode */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mknodat, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->mode, CHERI_CR_CTEMP0);

	/* [3] dev_t dev */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mknodat, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->dev, CHERI_CR_CTEMP0);

	/* [1] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mknodat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_openat_fill_uap(struct thread *td,
    struct openat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_openat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] int flag */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_openat, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flag, CHERI_CR_CTEMP0);

	/* [3] mode_t mode */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_openat, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->mode, CHERI_CR_CTEMP0);

	/* [1] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_openat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_readlinkat_fill_uap(struct thread *td,
    struct readlinkat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_readlinkat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [3] size_t bufsize */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_readlinkat, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->bufsize, CHERI_CR_CTEMP0);

	/* [1] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_readlinkat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Out_writes_bytes_(bufsize) char * buf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_readlinkat, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->bufsize)
			return (EPROT);

		CHERI_CTOPTR(uap->buf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_renameat_fill_uap(struct thread *td,
    struct renameat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int oldfd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_renameat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->oldfd, CHERI_CR_CTEMP0);

	/* [2] int newfd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_renameat, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->newfd, CHERI_CR_CTEMP0);

	/* [1] _In_z_ const char * old */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_renameat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->old))
			return (EPROT);

		CHERI_CTOPTR(uap->old, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _In_z_ const char * new */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_renameat, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->new))
			return (EPROT);

		CHERI_CTOPTR(uap->new, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_symlinkat_fill_uap(struct thread *td,
    struct symlinkat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_symlinkat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [0] _In_z_ char * path1 */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_symlinkat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path1))
			return (EPROT);

		CHERI_CTOPTR(uap->path1, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_z_ char * path2 */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_symlinkat, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path2))
			return (EPROT);

		CHERI_CTOPTR(uap->path2, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_unlinkat_fill_uap(struct thread *td,
    struct unlinkat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_unlinkat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] int flag */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_unlinkat, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flag, CHERI_CR_CTEMP0);

	/* [1] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_unlinkat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_posix_openpt_fill_uap(struct thread *td,
    struct posix_openpt_args *uap)
{
	struct chericap tmpcap;

	/* [0] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_posix_openpt, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_gssd_syscall_fill_uap(struct thread *td,
    struct gssd_syscall_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_gssd_syscall, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_jail_get_fill_uap(struct thread *td,
    struct cheriabi_jail_get_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] unsigned int iovcnt */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_jail_get, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->iovcnt, CHERI_CR_CTEMP0);

	/* [2] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_jail_get, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [0] _In_reads_(iovcnt) struct iovec_c * iovp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_jail_get, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->iovp) * uap->iovcnt))
			return (EPROT);

		CHERI_CTOPTR(uap->iovp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_jail_set_fill_uap(struct thread *td,
    struct cheriabi_jail_set_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] unsigned int iovcnt */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_jail_set, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->iovcnt, CHERI_CR_CTEMP0);

	/* [2] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_jail_set, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [0] _In_reads_(iovcnt) struct iovec_c * iovp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_jail_set, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->iovp) * uap->iovcnt))
			return (EPROT);

		CHERI_CTOPTR(uap->iovp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_jail_remove_fill_uap(struct thread *td,
    struct jail_remove_args *uap)
{
	struct chericap tmpcap;

	/* [0] int jid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_jail_remove, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->jid, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_closefrom_fill_uap(struct thread *td,
    struct closefrom_args *uap)
{
	struct chericap tmpcap;

	/* [0] int lowfd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_closefrom, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->lowfd, CHERI_CR_CTEMP0);

	return (0);
}

static inline int	CHERIABI_SYS_cheriabi___semctl_fill_uap(struct thread *td,
    struct cheriabi___semctl_args *uap);

static inline int
CHERIABI_SYS_cheriabi_msgctl_fill_uap(struct thread *td,
    struct cheriabi_msgctl_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int msqid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_msgctl, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->msqid, CHERI_CR_CTEMP0);

	/* [1] int cmd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_msgctl, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->cmd, CHERI_CR_CTEMP0);

	/* [2] _Inout_opt_ struct msqid_ds_c * buf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_msgctl, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->buf, CHERI_CR_CTEMP0);
		if (uap->buf != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->buf))
			return (EPROT);

		CHERI_CTOPTR(uap->buf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_shmctl_fill_uap(struct thread *td,
    struct shmctl_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int shmid */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_shmctl, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->shmid, CHERI_CR_CTEMP0);

	/* [1] int cmd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_shmctl, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->cmd, CHERI_CR_CTEMP0);

	/* [2] _Inout_ struct shmid_ds * buf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_shmctl, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->buf))
			return (EPROT);

		CHERI_CTOPTR(uap->buf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_lpathconf_fill_uap(struct thread *td,
    struct lpathconf_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int name */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lpathconf, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->name, CHERI_CR_CTEMP0);

	/* [0] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lpathconf, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS___cap_rights_get_fill_uap(struct thread *td,
    struct __cap_rights_get_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int version */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___cap_rights_get, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->version, CHERI_CR_CTEMP0);

	/* [1] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___cap_rights_get, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] _Out_ cap_rights_t * rightsp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___cap_rights_get, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->rightsp))
			return (EPROT);

		CHERI_CTOPTR(uap->rightsp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cap_getmode_fill_uap(struct thread *td,
    struct cap_getmode_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _Out_ u_int * modep */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cap_getmode, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->modep))
			return (EPROT);

		CHERI_CTOPTR(uap->modep, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_pdfork_fill_uap(struct thread *td,
    struct pdfork_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pdfork, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [0] _Out_ int * fdp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pdfork, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->fdp))
			return (EPROT);

		CHERI_CTOPTR(uap->fdp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_pdkill_fill_uap(struct thread *td,
    struct pdkill_args *uap)
{
	struct chericap tmpcap;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pdkill, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] int signum */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pdkill, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->signum, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_pdgetpid_fill_uap(struct thread *td,
    struct pdgetpid_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pdgetpid, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] _Out_ pid_t * pidp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pdgetpid, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->pidp))
			return (EPROT);

		CHERI_CTOPTR(uap->pidp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_pselect_fill_uap(struct thread *td,
    struct pselect_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int nd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pselect, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nd, CHERI_CR_CTEMP0);

	/* [1] _Inout_opt_ fd_set * in */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pselect, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->in, CHERI_CR_CTEMP0);
		if (uap->in != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->in))
			return (EPROT);

		CHERI_CTOPTR(uap->in, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Inout_opt_ fd_set * ou */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pselect, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->ou, CHERI_CR_CTEMP0);
		if (uap->ou != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->ou))
			return (EPROT);

		CHERI_CTOPTR(uap->ou, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _Inout_opt_ fd_set * ex */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pselect, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->ex, CHERI_CR_CTEMP0);
		if (uap->ex != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->ex))
			return (EPROT);

		CHERI_CTOPTR(uap->ex, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [4] _In_opt_ const struct timespec * ts */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pselect, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->ts, CHERI_CR_CTEMP0);
		if (uap->ts != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->ts))
			return (EPROT);

		CHERI_CTOPTR(uap->ts, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [5] _In_opt_ const sigset_t * sm */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pselect, 5);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->sm, CHERI_CR_CTEMP0);
		if (uap->sm != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->sm))
			return (EPROT);

		CHERI_CTOPTR(uap->sm, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getloginclass_fill_uap(struct thread *td,
    struct getloginclass_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] size_t namelen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getloginclass, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->namelen, CHERI_CR_CTEMP0);

	/* [0] _Out_writes_z_(namelen) char * namebuf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getloginclass, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->namebuf) * uap->namelen))
			return (EPROT);

		CHERI_CTOPTR(uap->namebuf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setloginclass_fill_uap(struct thread *td,
    struct setloginclass_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_z_ const char * namebuf */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setloginclass, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->namebuf))
			return (EPROT);

		CHERI_CTOPTR(uap->namebuf, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_rctl_get_racct_fill_uap(struct thread *td,
    struct rctl_get_racct_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] size_t inbuflen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_get_racct, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->inbuflen, CHERI_CR_CTEMP0);

	/* [3] size_t outbuflen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_get_racct, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->outbuflen, CHERI_CR_CTEMP0);

	/* [0] _In_reads_bytes_(inbuflen) const void * inbufp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_get_racct, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->inbuflen)
			return (EPROT);

		CHERI_CTOPTR(uap->inbufp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Out_writes_bytes_(outbuflen) void * outbufp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_get_racct, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->outbuflen)
			return (EPROT);

		CHERI_CTOPTR(uap->outbufp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_rctl_get_rules_fill_uap(struct thread *td,
    struct rctl_get_rules_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] size_t inbuflen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_get_rules, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->inbuflen, CHERI_CR_CTEMP0);

	/* [3] size_t outbuflen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_get_rules, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->outbuflen, CHERI_CR_CTEMP0);

	/* [0] _In_reads_bytes_(inbuflen) const void * inbufp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_get_rules, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->inbuflen)
			return (EPROT);

		CHERI_CTOPTR(uap->inbufp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Out_writes_bytes_(outbuflen) void * outbufp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_get_rules, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->outbuflen)
			return (EPROT);

		CHERI_CTOPTR(uap->outbufp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_rctl_get_limits_fill_uap(struct thread *td,
    struct rctl_get_limits_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] size_t inbuflen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_get_limits, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->inbuflen, CHERI_CR_CTEMP0);

	/* [3] size_t outbuflen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_get_limits, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->outbuflen, CHERI_CR_CTEMP0);

	/* [0] _In_reads_bytes_(inbuflen) const void * inbufp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_get_limits, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->inbuflen)
			return (EPROT);

		CHERI_CTOPTR(uap->inbufp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Out_writes_bytes_(outbuflen) void * outbufp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_get_limits, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->outbuflen)
			return (EPROT);

		CHERI_CTOPTR(uap->outbufp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_rctl_add_rule_fill_uap(struct thread *td,
    struct rctl_add_rule_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] size_t inbuflen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_add_rule, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->inbuflen, CHERI_CR_CTEMP0);

	/* [3] size_t outbuflen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_add_rule, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->outbuflen, CHERI_CR_CTEMP0);

	/* [0] _In_reads_bytes_(inbuflen) const void * inbufp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_add_rule, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->inbuflen)
			return (EPROT);

		CHERI_CTOPTR(uap->inbufp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Out_writes_bytes_(outbuflen) void * outbufp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_add_rule, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->outbuflen)
			return (EPROT);

		CHERI_CTOPTR(uap->outbufp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_rctl_remove_rule_fill_uap(struct thread *td,
    struct rctl_remove_rule_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] size_t inbuflen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_remove_rule, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->inbuflen, CHERI_CR_CTEMP0);

	/* [3] size_t outbuflen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_remove_rule, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->outbuflen, CHERI_CR_CTEMP0);

	/* [0] _In_reads_bytes_(inbuflen) const void * inbufp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_remove_rule, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->inbuflen)
			return (EPROT);

		CHERI_CTOPTR(uap->inbufp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _Out_writes_bytes_(outbuflen) void * outbufp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_remove_rule, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->outbuflen)
			return (EPROT);

		CHERI_CTOPTR(uap->outbufp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_posix_fallocate_fill_uap(struct thread *td,
    struct posix_fallocate_args *uap)
{
	struct chericap tmpcap;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_posix_fallocate, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] off_t offset */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_posix_fallocate, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->offset, CHERI_CR_CTEMP0);

	/* [2] off_t len */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_posix_fallocate, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->len, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_posix_fadvise_fill_uap(struct thread *td,
    struct posix_fadvise_args *uap)
{
	struct chericap tmpcap;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_posix_fadvise, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] off_t offset */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_posix_fadvise, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->offset, CHERI_CR_CTEMP0);

	/* [2] off_t len */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_posix_fadvise, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->len, CHERI_CR_CTEMP0);

	/* [3] int advice */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_posix_fadvise, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->advice, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_wait6_fill_uap(struct thread *td,
    struct cheriabi_wait6_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int idtype */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_wait6, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->idtype, CHERI_CR_CTEMP0);

	/* [1] id_t id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_wait6, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->id, CHERI_CR_CTEMP0);

	/* [3] int options */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_wait6, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->options, CHERI_CR_CTEMP0);

	/* [2] _Out_opt_ int * status */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_wait6, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->status, CHERI_CR_CTEMP0);
		if (uap->status != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->status))
			return (EPROT);

		CHERI_CTOPTR(uap->status, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [4] _Out_opt_ struct __wrusage * wrusage */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_wait6, 4);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->wrusage, CHERI_CR_CTEMP0);
		if (uap->wrusage != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->wrusage))
			return (EPROT);

		CHERI_CTOPTR(uap->wrusage, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [5] _Out_opt_ struct siginfo_c * info */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_wait6, 5);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->info, CHERI_CR_CTEMP0);
		if (uap->info != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->info))
			return (EPROT);

		CHERI_CTOPTR(uap->info, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cap_rights_limit_fill_uap(struct thread *td,
    struct cap_rights_limit_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cap_rights_limit, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] _In_ cap_rights_t * rightsp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cap_rights_limit, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->rightsp))
			return (EPROT);

		CHERI_CTOPTR(uap->rightsp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cap_ioctls_limit_fill_uap(struct thread *td,
    struct cap_ioctls_limit_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cap_ioctls_limit, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] size_t ncmds */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cap_ioctls_limit, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->ncmds, CHERI_CR_CTEMP0);

	/* [1] _In_reads_(ncmds) const u_long * cmds */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cap_ioctls_limit, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->cmds) * uap->ncmds))
			return (EPROT);

		CHERI_CTOPTR(uap->cmds, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cap_ioctls_get_fill_uap(struct thread *td,
    struct cap_ioctls_get_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cap_ioctls_get, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] size_t maxcmds */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cap_ioctls_get, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->maxcmds, CHERI_CR_CTEMP0);

	/* [1] _Out_writes_(maxcmds) u_long * cmds */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cap_ioctls_get, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->cmds) * uap->maxcmds))
			return (EPROT);

		CHERI_CTOPTR(uap->cmds, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cap_fcntls_limit_fill_uap(struct thread *td,
    struct cap_fcntls_limit_args *uap)
{
	struct chericap tmpcap;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cap_fcntls_limit, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] uint32_t fcntlrights */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cap_fcntls_limit, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fcntlrights, CHERI_CR_CTEMP0);

	return (0);
}

static inline int
CHERIABI_SYS_cap_fcntls_get_fill_uap(struct thread *td,
    struct cap_fcntls_get_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cap_fcntls_get, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] _Out_ uint32_t * fcntlrightsp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cap_fcntls_get, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->fcntlrightsp))
			return (EPROT);

		CHERI_CTOPTR(uap->fcntlrightsp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_bindat_fill_uap(struct thread *td,
    struct bindat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_bindat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] int s */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_bindat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->s, CHERI_CR_CTEMP0);

	/* [3] int namelen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_bindat, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->namelen, CHERI_CR_CTEMP0);

	/* [2] _In_reads_bytes_(namelen) caddr_t name */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_bindat, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->namelen)
			return (EPROT);

		CHERI_CTOPTR(uap->name, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_connectat_fill_uap(struct thread *td,
    struct connectat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_connectat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] int s */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_connectat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->s, CHERI_CR_CTEMP0);

	/* [3] int namelen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_connectat, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->namelen, CHERI_CR_CTEMP0);

	/* [2] _In_reads_bytes_(namelen) caddr_t name */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_connectat, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < 1 * uap->namelen)
			return (EPROT);

		CHERI_CTOPTR(uap->name, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_chflagsat_fill_uap(struct thread *td,
    struct chflagsat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_chflagsat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [2] u_long flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_chflagsat, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [3] int atflag */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_chflagsat, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->atflag, CHERI_CR_CTEMP0);

	/* [1] _In_z_ const char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_chflagsat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_accept4_fill_uap(struct thread *td,
    struct accept4_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int s */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_accept4, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->s, CHERI_CR_CTEMP0);

	/* [3] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_accept4, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [2] _Inout_opt_ socklen_t *__restrict anamelen */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_accept4, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->anamelen, CHERI_CR_CTEMP0);
		if (uap->anamelen != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->anamelen))
			return (EPROT);

		CHERI_CTOPTR(uap->anamelen, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [1] _Out_writes_bytes_opt_(*anamelen) struct sockaddr *__restrict name */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_accept4, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->name, CHERI_CR_CTEMP0);
		if (uap->name != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		if (uap->anamelen == NULL)
			return (EINVAL);
		size_t reqlen;
		if (sizeof(uap->anamelen) == 2)
			reqlen = fuword16(uap->anamelen);
		else if (sizeof(uap->anamelen) == 4)
			reqlen = fuword32(uap->anamelen);
		else if (sizeof(uap->anamelen) == 8)
			reqlen = fuword64(uap->anamelen);
		else
			panic("unhandled dependant argument size %zu", sizeof(uap->anamelen));
		reqlen = fuword(uap->anamelen);
		if (reqlen == -1)
			return (EINVAL);
		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < reqlen)
			return (EPROT);

		CHERI_CTOPTR(uap->name, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_pipe2_fill_uap(struct thread *td,
    struct pipe2_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] int flags */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pipe2, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flags, CHERI_CR_CTEMP0);

	/* [0] _Out_writes_(2) int * fildes */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pipe2, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->fildes) * 2))
			return (EPROT);

		CHERI_CTOPTR(uap->fildes, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_aio_mlock_fill_uap(struct thread *td,
    struct cheriabi_aio_mlock_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] _In_ struct aiocb_c * aiocbp */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_mlock, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->aiocbp))
			return (EPROT);

		CHERI_CTOPTR(uap->aiocbp, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int	CHERIABI_SYS_cheriabi_procctl_fill_uap(struct thread *td,
    struct cheriabi_procctl_args *uap);

static inline int
CHERIABI_SYS_ppoll_fill_uap(struct thread *td,
    struct ppoll_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [1] u_int nfds */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ppoll, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->nfds, CHERI_CR_CTEMP0);

	/* [0] _Inout_updates_(nfds) struct pollfd * fds */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ppoll, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->fds) * uap->nfds))
			return (EPROT);

		CHERI_CTOPTR(uap->fds, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_opt_ const struct timespec * ts */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ppoll, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->ts, CHERI_CR_CTEMP0);
		if (uap->ts != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->ts))
			return (EPROT);

		CHERI_CTOPTR(uap->ts, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [3] _In_opt_ const sigset_t * set */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ppoll, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		CHERI_CTOINT(uap->set, CHERI_CR_CTEMP0);
		if (uap->set != NULL)
			return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->set))
			return (EPROT);

		CHERI_CTOPTR(uap->set, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_futimens_fill_uap(struct thread *td,
    struct futimens_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_futimens, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [1] _In_reads_(2) struct timespec * times */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_futimens, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->times) * 2))
			return (EPROT);

		CHERI_CTOPTR(uap->times, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_utimensat_fill_uap(struct thread *td,
    struct utimensat_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] int fd */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_utimensat, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->fd, CHERI_CR_CTEMP0);

	/* [3] int flag */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_utimensat, 3);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->flag, CHERI_CR_CTEMP0);

	/* [1] _In_z_ char * path */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_utimensat, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->path))
			return (EPROT);

		CHERI_CTOPTR(uap->path, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	/* [2] _In_reads_(2) struct timespec * times */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_utimensat, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < (sizeof(*uap->times) * 2))
			return (EPROT);

		CHERI_CTOPTR(uap->times, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_numa_getaffinity_fill_uap(struct thread *td,
    struct numa_getaffinity_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] cpuwhich_t which */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_numa_getaffinity, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->which, CHERI_CR_CTEMP0);

	/* [1] id_t id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_numa_getaffinity, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->id, CHERI_CR_CTEMP0);

	/* [2] _Out_ struct vm_domain_policy_entry * policy */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_numa_getaffinity, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_STORE);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->policy))
			return (EPROT);

		CHERI_CTOPTR(uap->policy, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

static inline int
CHERIABI_SYS_numa_setaffinity_fill_uap(struct thread *td,
    struct numa_setaffinity_args *uap)
{
	struct chericap tmpcap;
	u_int tag;
	register_t perms, reqperms;
	register_t sealed;
	size_t base __unused, length, offset;

	/* [0] cpuwhich_t which */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_numa_setaffinity, 0);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->which, CHERI_CR_CTEMP0);

	/* [1] id_t id */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_numa_setaffinity, 1);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CTOINT(uap->id, CHERI_CR_CTEMP0);

	/* [2] _In_ const struct vm_domain_policy_entry * policy */
	cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_numa_setaffinity, 2);
	CHERI_CLC(CHERI_CR_CTEMP0, CHERI_CR_KDC, &tmpcap, 0);
	CHERI_CGETTAG(tag, CHERI_CR_CTEMP0);
	if (!tag) {
		return (EPROT);
	} else {
		CHERI_CGETPERM(perms, CHERI_CR_CTEMP0);
		reqperms = (CHERI_PERM_GLOBAL|CHERI_PERM_LOAD);
		if ((perms & reqperms) != reqperms)
			return (EPROT);

		CHERI_CGETSEALED(sealed, CHERI_CR_CTEMP0);
		if (sealed)
			return (EPROT);

		CHERI_CGETLEN(length, CHERI_CR_CTEMP0);
		CHERI_CGETOFFSET(offset, CHERI_CR_CTEMP0);
		if (offset >= length)
			return (EPROT);
		length -= offset;
		if (length < sizeof(*uap->policy))
			return (EPROT);

		CHERI_CTOPTR(uap->policy, CHERI_CR_CTEMP0, CHERI_CR_KDC);
	}

	return (0);
}

#endif /* !_SYS_COMPAT_CHERIABI_FILL_UAP_H_ */
